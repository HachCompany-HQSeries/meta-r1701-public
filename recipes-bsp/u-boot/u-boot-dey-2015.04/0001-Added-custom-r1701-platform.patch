From 2bb96cbf53d43a25b4fd7799e4f4c4d250cd1ce6 Mon Sep 17 00:00:00 2001
From: Tim Higgins <thiggins@hach.com>
Date: Thu, 2 Nov 2017 15:11:37 -0600
Subject: [PATCH 1/2] Added custom r1701 platform.

---
 arch/arm/Kconfig             |   5 +
 board/digi/r1701/Kconfig     |  15 ++
 board/digi/r1701/MAINTAINERS |   6 +
 board/digi/r1701/Makefile    |  10 +
 board/digi/r1701/r1701.c     | 584 +++++++++++++++++++++++++++++++++++++++++++
 configs/r1701_defconfig      |   7 +
 include/configs/r1701.h      | 259 +++++++++++++++++++
 7 files changed, 886 insertions(+)
 create mode 100644 board/digi/r1701/Kconfig
 create mode 100644 board/digi/r1701/MAINTAINERS
 create mode 100644 board/digi/r1701/Makefile
 create mode 100644 board/digi/r1701/r1701.c
 create mode 100644 configs/r1701_defconfig
 create mode 100644 include/configs/r1701.h

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 6be5d26878..57fe8a8a59 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -589,6 +589,10 @@ config TARGET_CCIMX6ULSTARTER
         bool "Support ccimx6ulstarter"
         select CPU_V7

+config TARGET_R1701
+        bool "Support for the r1701"
+        select CPU_V7
+
 config TARGET_PICOSOM_IMX6UL
         bool "Support picosom-imx6ul"
         select CPU_V7
@@ -868,6 +872,7 @@ source "board/denx/m53evk/Kconfig"
 source "board/digi/ccimx6sbc/Kconfig"
 source "board/digi/ccimx6ulsbc/Kconfig"
 source "board/digi/ccimx6ulstarter/Kconfig"
+source "board/digi/r1701/Kconfig"
 source "board/embest/mx6boards/Kconfig"
 source "board/esg/ima3-mx53/Kconfig"
 source "board/freescale/ls2085a/Kconfig"
diff --git a/board/digi/r1701/Kconfig b/board/digi/r1701/Kconfig
new file mode 100644
index 0000000000..caa2456cce
--- /dev/null
+++ b/board/digi/r1701/Kconfig
@@ -0,0 +1,15 @@
+if TARGET_R1701
+
+config SYS_BOARD
+	default "r1701"
+
+config SYS_VENDOR
+	default "digi"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "r1701"
+
+endif
diff --git a/board/digi/r1701/MAINTAINERS b/board/digi/r1701/MAINTAINERS
new file mode 100644
index 0000000000..8e4c57f6fc
--- /dev/null
+++ b/board/digi/r1701/MAINTAINERS
@@ -0,0 +1,6 @@
+CCIMX6ULSTARTER BOARD
+M:	Tim Higgins <thiggins@hach.com>
+S:	Supported
+F:	board/digi/r1701/
+F:	include/configs/r1701.h
+F:	configs/r1701_defconfig
diff --git a/board/digi/r1701/Makefile b/board/digi/r1701/Makefile
new file mode 100644
index 0000000000..be50bf5b9e
--- /dev/null
+++ b/board/digi/r1701/Makefile
@@ -0,0 +1,10 @@
+# (C) Copyright 2016 Digi International, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := r1701.o ../ccimx6ul/ccimx6ul.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  ../ccimx6ul/plugin.bin
+$(obj)/../ccimx6ul/plugin.bin: $(obj)/../ccimx6ul/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff --git a/board/digi/r1701/r1701.c b/board/digi/r1701/r1701.c
new file mode 100644
index 0000000000..3d58ea2856
--- /dev/null
+++ b/board/digi/r1701/r1701.c
@@ -0,0 +1,584 @@
+/*
+ * Copyright (C) 2016 Digi International, Inc
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/io.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <i2c.h>
+#include <linux/sizes.h>
+#include <linux/fb.h>
+#include <miiphy.h>
+#include <mmc.h>
+#include <mxsfb.h>
+#include <netdev.h>
+#include <usb.h>
+#include <usb/ehci-fsl.h>
+#include <command.h>
+#include "../ccimx6ul/ccimx6ul.h"
+#include "../common/carrier_board.h"
+#include "../common/helper.h"
+#include "../common/hwid.h"
+#include "../common/mca_registers.h"
+
+#ifdef CONFIG_POWER
+#include <power/pmic.h>
+#include <power/pfuze300_pmic.h>
+#include "../../freescale/common/pfuze.h"
+#endif
+
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FSL_FASTBOOT*/
+
+DECLARE_GLOBAL_DATA_PTR;
+
+unsigned int board_version = CARRIERBOARD_VERSION_UNDEFINED;
+unsigned int board_id = CARRIERBOARD_ID_UNDEFINED;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_HIGH   |                                   \
+	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST)
+
+#define MDIO_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST | PAD_CTL_ODE)
+
+#define ENET_CLK_PAD_CTRL  (PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_HIGH   | PAD_CTL_SRE_FAST)
+
+#define OTG_ID_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define GPI_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+static iomux_v3_cfg_t const uart5_pads[] = {
+	MX6_PAD_UART5_TX_DATA__UART5_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_UART5_RX_DATA__UART5_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+#ifdef CONFIG_CONSOLE_ENABLE_GPIO
+static iomux_v3_cfg_t const ext_gpios_pads[] = {
+	MX6_PAD_GPIO1_IO04__GPIO1_IO04 | MUX_PAD_CTRL(GPI_PAD_CTRL),
+	MX6_PAD_JTAG_TDO__GPIO1_IO12 | MUX_PAD_CTRL(GPI_PAD_CTRL),
+	MX6_PAD_JTAG_TDI__GPIO1_IO13 | MUX_PAD_CTRL(GPI_PAD_CTRL),
+	MX6_PAD_JTAG_TMS__GPIO1_IO11 | MUX_PAD_CTRL(GPI_PAD_CTRL),
+	MX6_PAD_JTAG_TRST_B__GPIO1_IO15 | MUX_PAD_CTRL(GPI_PAD_CTRL),
+	MX6_PAD_JTAG_TCK__GPIO1_IO14 | MUX_PAD_CTRL(GPI_PAD_CTRL),
+};
+#endif
+
+/* micro SD */
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6_PAD_CSI_VSYNC__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_HSYNC__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_DATA00__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_DATA01__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_DATA02__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_CSI_DATA03__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C2 */
+struct i2c_pads_info i2c2_pad_info = {
+	.scl = {
+		.i2c_mode =  MX6_PAD_GPIO1_IO00__I2C2_SCL | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO00__GPIO1_IO00 | PC,
+		.gp = IMX_GPIO_NR(1, 0),
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_GPIO1_IO01__I2C2_SDA | PC,
+		.gpio_mode = MX6_PAD_GPIO1_IO01__GPIO1_IO01 | PC,
+		.gp = IMX_GPIO_NR(1, 1),
+	},
+};
+#endif
+
+#ifdef CONFIG_FEC_MXC
+/*
+ * pin conflicts for fec1 and fec2, GPIO1_IO06 and GPIO1_IO07 can only
+ * be used for ENET1 or ENET2, cannot be used for both.
+ */
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),
+	MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_DATA1__ENET1_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_EN__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+	MX6_PAD_ENET1_RX_DATA0__ENET1_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_DATA1__ENET1_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	/*
+	 * GPIO3_IO2 is used as PHY reset in Starter Board v1 and as PHY power
+	 * enable on Starter Board v2
+	 */
+	MX6_PAD_LCD_HSYNC__GPIO3_IO02 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_fec(void)
+{
+	imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart5_pads, ARRAY_SIZE(uart5_pads));
+}
+
+#ifdef CONFIG_FSL_ESDHC
+static struct fsl_esdhc_cfg usdhc_cfg[] = {
+	{USDHC2_BASE_ADDR, 0, 4},
+};
+
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	int dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6 ;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	if (dev_no == 1 && mx6_esdhc_fused(USDHC1_BASE_ADDR))
+		dev_no = 0;
+
+	return dev_no;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	/* CD not connected. Assume microSD card present */
+	return 1;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int i, ret;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC2
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return -EINVAL;
+		}
+
+		ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+		if (ret) {
+			printf("Warning: failed to initialize mmc dev %d\n", i);
+		}
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+void reset_phy()
+{
+	/*
+	 * The reset line must be held low for a minimum of 100usec and cannot
+	 * be deasserted before 25ms have passed since the power supply has
+	 * reached 80% of the operating voltage. At this point of the code
+	 * we can assume the second premise is already accomplished.
+	 */
+	if (board_version == 1) {
+		int phy_reset_gpio = IMX_GPIO_NR(3, 2);
+
+		/* Assert PHY reset (low) */
+		gpio_direction_output(phy_reset_gpio , 0);
+		udelay(100);
+		/* Deassert PHY reset (high) */
+		gpio_set_value(phy_reset_gpio, 1);
+	} else {
+		/* MCA_IO7 is connected to PHY reset */
+		int reset = (1 << 7);
+
+		/* Configure as output */
+		mca_update_bits(MCA_CC6UL_GPIO_DIR_0, reset, reset);
+		/* Assert PHY reset (low) */
+		mca_update_bits(MCA_CC6UL_GPIO_DATA_0, reset, 0);
+		udelay(100);
+		/* Deassert PHY reset (high) */
+		mca_update_bits(MCA_CC6UL_GPIO_DATA_0, reset, reset);
+	}
+}
+
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_fec();
+
+	ret = fecmxc_initialize_multi(bis, CONFIG_FEC_ENET_DEV,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC%d MXC: %s:failed\n", CONFIG_FEC_ENET_DEV, __func__);
+
+	reset_phy();
+
+	return 0;
+}
+
+static int setup_fec(int fec_id)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+	int ret;
+
+	if (board_version != 1) {
+		/* Enable PHY power */
+		int phy_power_gpio = IMX_GPIO_NR(3, 2);
+
+		gpio_direction_output(phy_power_gpio , 1);
+	}
+
+	if (0 == fec_id) {
+		if (check_module_fused(MX6_MODULE_ENET1))
+			return -1;
+
+		/* Use 50M anatop loopback REF_CLK1 for ENET1, clear gpr1[13], set gpr1[17]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC1_MASK,
+				IOMUX_GPR1_FEC1_CLOCK_MUX1_SEL_MASK);
+	} else {
+		if (check_module_fused(MX6_MODULE_ENET2))
+			return -1;
+
+		/* Use 50M anatop loopback REF_CLK2 for ENET2, clear gpr1[14], set gpr1[18]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC2_MASK,
+				IOMUX_GPR1_FEC2_CLOCK_MUX1_SEL_MASK);
+	}
+
+	ret = enable_fec_anatop_clock(fec_id, ENET_50MHZ);
+	if (ret)
+		return ret;
+
+	enable_enet_clk(1);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8190);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_OTHERREGS_OFFSET	0x800
+#define UCTRL_PWR_POL		(1 << 9)
+
+static iomux_v3_cfg_t const usb_otg_pads[] = {
+	MX6_PAD_GPIO1_IO00__ANATOP_OTG1_ID | MUX_PAD_CTRL(OTG_ID_PAD_CTRL),
+};
+
+/* At default the 3v3 enables the MIC2026 for VBUS power */
+static void setup_usb(void)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+					 ARRAY_SIZE(usb_otg_pads));
+}
+
+int board_usb_phy_mode(int port)
+{
+	if (port == 1)
+		return USB_INIT_HOST;
+	else
+		return usb_phy_mode(port);
+}
+
+int board_ehci_hcd_init(int port)
+{
+	u32 *usbnc_usb_ctrl;
+
+	if (port > 1)
+		return -EINVAL;
+
+	usbnc_usb_ctrl = (u32 *)(USB_BASE_ADDR + USB_OTHERREGS_OFFSET +
+				 port * 4);
+
+	/* Set Power polarity */
+	setbits_le32(usbnc_usb_ctrl, UCTRL_PWR_POL);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_CONSOLE_ENABLE_GPIO
+static void setup_iomux_ext_gpios(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ext_gpios_pads,
+					 ARRAY_SIZE(ext_gpios_pads));
+}
+#endif
+
+int board_early_init_f(void)
+{
+#ifdef CONFIG_CONSOLE_ENABLE_GPIO
+	int ext_gpios[] =  {
+		IMX_GPIO_NR(1, 4),
+		IMX_GPIO_NR(1, 12),
+		IMX_GPIO_NR(1, 13),
+		IMX_GPIO_NR(1, 11),
+		IMX_GPIO_NR(1, 15),
+		IMX_GPIO_NR(1, 14),
+	};
+	int console_enable_gpio_nr = ext_gpios[CONFIG_CONSOLE_ENABLE_GPIO_NR];
+
+	setup_iomux_ext_gpios();
+	gpio_direction_input(console_enable_gpio_nr);
+#endif
+
+	setup_iomux_uart();
+
+#ifdef CONFIG_CONSOLE_DISABLE
+	gd->flags |= (GD_FLG_DISABLE_CONSOLE | GD_FLG_SILENT);
+#ifdef CONFIG_CONSOLE_ENABLE_GPIO
+	if (console_enable_gpio(console_enable_gpio_nr))
+		gd->flags &= ~(GD_FLG_DISABLE_CONSOLE | GD_FLG_SILENT);
+#endif
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_POWER
+int power_init_board(void)
+{
+	/* SOM power init */
+	power_init_ccimx6ul();
+
+	return 0;
+}
+#endif
+
+int board_init(void)
+{
+	/* SOM init */
+	ccimx6ul_init();
+
+	board_version = get_carrierboard_version();
+	/* Treat Starter Board version 1 (prototypes) as version 2 */
+	if (board_version == 1)
+		board_version = 2;
+	board_id = get_carrierboard_id();
+
+#ifdef CONFIG_I2C_MULTI_BUS
+	/* Setup I2C2 (Groove connector) */
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c2_pad_info);
+#endif
+
+#ifdef	CONFIG_FEC_MXC
+	setup_fec(CONFIG_FEC_ENET_DEV);
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+	setup_usb();
+#endif
+
+	return 0;
+}
+
+void platform_default_environment(void)
+{
+	char cmd[80];
+
+	som_default_environment();
+
+	/* Set $board_version variable if defined in OTP bits */
+	if (board_version > 0) {
+		sprintf(cmd, "setenv -f board_version %d", board_version);
+		run_command(cmd, 0);
+	}
+
+	/* Set $board_id variable if defined in OTP bits */
+	if (board_id > 0) {
+		sprintf(cmd, "setenv -f board_id %d", board_id);
+		run_command(cmd, 0);
+	}
+}
+
+int board_late_init(void)
+{
+	/* SOM late init */
+	ccimx6ul_late_init();
+
+	/* Set default dynamic variables */
+	platform_default_environment();
+
+	set_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);
+
+	return 0;
+}
+
+#if defined(CONFIG_OF_BOARD_SETUP)
+/* Platform function to modify the FDT as needed */
+int ft_board_setup(void *blob, bd_t *bd)
+{
+	/* Re-read HWID which could have been overriden by U-Boot commands */
+	fdt_fixup_hwid(blob);
+
+	fdt_fixup_ccimx6ul(blob);
+	fdt_fixup_carrierboard(blob);
+
+	return 0;
+}
+#endif /* CONFIG_OF_BOARD_SETUP */
+
+int checkboard(void)
+{
+	print_ccimx6ul_info();
+	print_carrierboard_info();
+	printf("Boot device:  %s\n",
+	       is_boot_from_usb() ? "USB" : get_boot_device_name());
+
+	return 0;
+}
+
+#ifdef CONFIG_FSL_FASTBOOT
+
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc0");
+		break;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "boota mmc1");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "nand");
+		if (!getenv("fbparts"))
+			setenv("fbparts", ANDROID_FASTBOOT_NAND_PARTS);
+		if (!getenv("bootcmd"))
+			setenv("bootcmd",
+				"nand read ${loadaddr} ${boot_nand_offset} "
+				"${boot_nand_size};boota ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+int check_recovery_cmd_file(void)
+{
+	int recovery_mode = 0;
+
+	recovery_mode = recovery_check_and_clean_flag();
+
+	return recovery_mode;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc0 recovery");
+		break;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "boota mmc1 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"nand read ${loadaddr} ${recovery_nand_offset} "
+				"${recovery_nand_size};boota ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FSL_FASTBOOT*/
diff --git a/configs/r1701_defconfig b/configs/r1701_defconfig
new file mode 100644
index 0000000000..a23f37d211
--- /dev/null
+++ b/configs/r1701_defconfig
@@ -0,0 +1,7 @@
+CONFIG_ARM=y
+CONFIG_TARGET_R1701=y
+CONFIG_DM=y
+CONFIG_IMX_HAB=y
+CONFIG_SECURE_BOOT=y
+CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/digi/ccimx6ul/imximage.cfg,MX6UL,DDR_MB=256"
+CONFIG_DM_THERMAL=y
diff --git a/include/configs/r1701.h b/include/configs/r1701.h
new file mode 100644
index 0000000000..8a8727408c
--- /dev/null
+++ b/include/configs/r1701.h
@@ -0,0 +1,259 @@
+/*
+ * Copyright (C) 2016 Digi International, Inc.
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Digi ConnecCore 6UL Starter board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef CCIMX6ULSTARTER_CONFIG_H
+#define CCIMX6ULSTARTER_CONFIG_H
+
+#include "ccimx6ul_common.h"
+
+#define CONFIG_BOARD_DESCRIPTION	"R1701 Board"
+
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+/* uncomment for BEE support, needs to enable CONFIG_CMD_FUSE */
+/* #define CONFIG_CMD_BEE */
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_NO_FLASH
+
+#if defined(CONFIG_SYS_BOOT_NAND)
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_CMD_MTDPARTS
+#define CONFIG_MTD_DEVICE
+#define CONFIG_MTD_PARTITIONS
+#define CONFIG_CMD_UPDATE_NAND
+#define CONFIG_SYS_STORAGE_MEDIA	"nand"
+#define CONFIG_CMD_BOOTSTREAM
+#else
+#define CONFIG_ENV_IS_IN_MMC
+#define CONFIG_CMD_UPDATE_MMC
+#define CONFIG_SYS_STORAGE_MEDIA	"mmc"
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* NAND stuff */
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0x40000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* DMA stuff, needed for GPMI/MXS NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif
+
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+
+/* U-Boot Environment */
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET		(3 * SZ_1M)
+#define CONFIG_ENV_SIZE			SZ_128K
+#endif
+#define CONFIG_SYS_REDUNDANT_ENVIRONMENT
+#define CONFIG_DYNAMIC_ENV_LOCATION
+#if (CONFIG_DDR_MB == 1024)
+# define CONFIG_ENV_PARTITION_SIZE	(3 * SZ_1M)
+#else
+# define CONFIG_ENV_PARTITION_SIZE	(1 * SZ_1M)
+#endif /* (CONFIG_DDR_MB == 1024) */
+/* The environment may use any good blocks within the "environment" partition */
+#define CONFIG_ENV_RANGE		CONFIG_ENV_PARTITION_SIZE
+
+/* Serial port */
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART5_BASE
+#define CONFIG_CONS_INDEX		5
+#define CONFIG_CONSOLE_PORT		"ttymxc4"
+#define CONFIG_BAUDRATE			115200
+
+#define CONFIG_MODULE_FUSE
+#define CONFIG_OF_SYSTEM_SETUP
+
+/* Ethernet */
+#define CONFIG_FEC_ENET_DEV		0
+#if (CONFIG_FEC_ENET_DEV == 0)
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x0
+#define CONFIG_FEC_XCV_TYPE             RMII
+#elif (CONFIG_FEC_ENET_DEV == 1)
+#define IMX_FEC_BASE			ENET2_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x1
+#define CONFIG_FEC_XCV_TYPE             RMII
+#endif
+
+#define CONFIG_DEFAULT_FDT_FILE		"zImage-imx6ul-" CONFIG_SYS_BOARD ".dtb"
+
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+
+#ifdef CONFIG_SECURE_BOOT
+/*
+ * Authenticate bootscript before running it. IVT offset is at
+ * ${filesize} - CONFIG_CSF_SIZE - IVT_SIZE (0x20)
+ * Use 0x4000 as CSF_SIZE, as this is the value used by the script
+ * to sign / encrypt the bootscript
+ */
+#define CONFIG_BOOTCOMMAND \
+	"if run loadscript; then " \
+		"setexpr bs_ivt_offset ${filesize} - 0x4020;" \
+		"if hab_auth_img ${loadaddr} ${bs_ivt_offset}; then " \
+			"source ${loadaddr};" \
+		"fi; " \
+	"fi;"
+#else
+#define CONFIG_BOOTCOMMAND \
+	"if run loadscript; then " \
+		"source ${loadaddr};" \
+	"fi;"
+
+#endif	/* CONFIG_SECURE_BOOT */
+
+#define CONFIG_COMMON_ENV	\
+	CONFIG_DEFAULT_NETWORK_SETTINGS \
+	CONFIG_EXTRA_NETWORK_SETTINGS \
+	"boot_fdt=yes\0" \
+	"bootargs_nfs=" \
+		"if test ${ip_dyn} = yes; then " \
+			"bootargs_ip=\"ip=dhcp\";" \
+		"else " \
+			"bootargs_ip=\"ip=\\${ipaddr}:\\${serverip}:" \
+			"\\${gatewayip}:\\${netmask}:\\${hostname}:" \
+			"eth0:off\";" \
+		"fi;\0" \
+	"bootargs_nfs_linux=run bootargs_nfs;" \
+		"setenv bootargs console=${console},${baudrate} " \
+		"${bootargs_linux} root=/dev/nfs " \
+		"${bootargs_ip} nfsroot=${serverip}:${rootpath},v3,tcp " \
+		"${mtdparts} ${bootargs_once} ${extra_bootargs}\0" \
+	"bootargs_tftp=" \
+		"if test ${ip_dyn} = yes; then " \
+			"bootargs_ip=\"ip=dhcp\";" \
+		"else " \
+			"bootargs_ip=\"ip=\\${ipaddr}:\\${serverip}:" \
+			"\\${gatewayip}:\\${netmask}:\\${hostname}:" \
+			"eth0:off\";" \
+		"fi;\0" \
+	"bootargs_tftp_linux=run bootargs_tftp;" \
+		"setenv bootargs console=${console},${baudrate} " \
+		"${bootargs_linux} root=/dev/nfs " \
+		"${bootargs_ip} nfsroot=${serverip}:${rootpath},v3,tcp " \
+		"${mtdparts} ${bootargs_once} ${extra_bootargs}\0" \
+	"console=" CONFIG_CONSOLE_PORT "\0" \
+	"fdt_addr=0x83000000\0" \
+	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_addr=0x83800000\0" \
+	"initrd_file=uramdisk.img\0" \
+	"initrd_high=0xffffffff\0" \
+	"recovery_file=recovery.img\0" \
+	"script=boot.scr\0" \
+	"uboot_file=u-boot.imx\0" \
+	"zimage=zImage-" CONFIG_SYS_BOARD ".bin\0" "model-type=HQ_MPP\0" "model-name=HQ1110\0" "test-mode=On\0" "serial-number=1812345678\0"
+
+#if defined(CONFIG_SYS_BOOT_NAND)
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_COMMON_ENV \
+	CONFIG_ENV_MTD_SETTINGS \
+	"bootargs_linux=\0" \
+	"bootargs_nand_linux=setenv bootargs console=${console},${baudrate} " \
+		"${bootargs_linux} ${mtdparts} ubi.mtd=${mtdlinuxindex} " \
+		"ubi.mtd=${mtdrootfsindex} root=ubi1_0 " \
+		"rootfstype=ubifs rw " \
+		"${bootargs_once} ${extra_bootargs}\0" \
+	"install_linux_fw_sd=if load mmc 0 ${loadaddr} install_linux_fw_sd.scr;then " \
+			"source ${loadaddr};" \
+		"fi;\0" \
+	"linux_file=hach-image-" CONFIG_SYS_BOARD ".boot.ubifs\0" \
+	"loadscript=" \
+		"if test -z \"${mtdbootpart}\"; then " \
+			"setenv mtdbootpart " CONFIG_LINUX_PARTITION ";" \
+		"fi;" \
+		"if ubi part ${mtdbootpart}; then " \
+			"if ubifsmount ubi0:${mtdbootpart}; then " \
+				"ubifsload ${loadaddr} ${script};" \
+			"fi;" \
+		"fi;\0" \
+	"mtdbootpart=" CONFIG_LINUX_PARTITION "\0" \
+	"mtdlinuxindex=" CONFIG_ENV_MTD_LINUX_INDEX "\0" \
+	"mtdrecoveryindex=" CONFIG_ENV_MTD_RECOVERY_INDEX "\0" \
+	"mtdrootfsindex=" CONFIG_ENV_MTD_ROOTFS_INDEX "\0" \
+	"mtdupdateindex=" CONFIG_ENV_MTD_UPDATE_INDEX "\0" \
+	"recoverycmd=" \
+		"setenv mtdbootpart " CONFIG_RECOVERY_PARTITION ";" \
+		"boot\0" \
+	"rootfs_file=hach-image-" CONFIG_SYS_BOARD ".ubifs\0" \
+	""	/* end line */
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_COMMON_ENV \
+	"loadscript=load mmc ${mmcbootdev}:${mmcpart} ${loadaddr} ${script}\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		"${mtdparts} " \
+		"root=${mmcroot}\0" \
+	""	/* end line */
+#endif
+
+#define CONFIG_SYS_MMC_ENV_DEV		0   /* USDHC2 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk1p2"  /* USDHC2 */
+
+/* Carrier board version in OTP bits */
+#define CONFIG_HAS_CARRIERBOARD_VERSION
+#ifdef CONFIG_HAS_CARRIERBOARD_VERSION
+/* The carrier board version is stored in Bank 4 Word 6 (GP1)
+ * in bits 3..0 */
+#define CONFIG_CARRIERBOARD_VERSION_BANK	4
+#define CONFIG_CARRIERBOARD_VERSION_WORD	6
+#define CONFIG_CARRIERBOARD_VERSION_MASK	0xf
+#define CONFIG_CARRIERBOARD_VERSION_OFFSET	0
+#endif /* CONFIG_HAS_CARRIERBOARD_VERSION */
+
+/* Carrier board ID in OTP bits */
+#define CONFIG_HAS_CARRIERBOARD_ID
+#ifdef CONFIG_HAS_CARRIERBOARD_ID
+/* The carrier board ID is stored in Bank 4 Word 6 (GP1)
+ * in bits 11..4 */
+#define CONFIG_CARRIERBOARD_ID_BANK	4
+#define CONFIG_CARRIERBOARD_ID_WORD	6
+#define CONFIG_CARRIERBOARD_ID_MASK	0xff
+#define CONFIG_CARRIERBOARD_ID_OFFSET	4
+#endif /* CONFIG_HAS_CARRIERBOARD_ID */
+
+#define CONFIG_BOOTDELAY               1
+
+/* UBI and UBIFS support */
+#define CONFIG_CMD_UBI
+#define CONFIG_RBTREE
+#define CONFIG_CMD_UBIFS
+#define CONFIG_LZO
+#define CONFIG_DIGI_UBI
+
+#endif /* CCIMX6ULSTARTER_CONFIG_H */
--
2.11.0

