From 0b371703d20e2792f7cab0c0021a63c6fa59610a Mon Sep 17 00:00:00 2001
From: Robert Yang <ryang@hach.com>
Date: Mon, 1 Jul 2019 17:28:49 +0000
Subject: [PATCH 10/10] Adding-HPP-and-MPP-device-trees

---
 arch/arm/boot/dts/Makefile             |   4 +-
 arch/arm/boot/dts/imx6ul-r1701-hpp.dts | 952 +++++++++++++++++++++++++
 arch/arm/boot/dts/imx6ul-r1701-mpp.dts | 804 +++++++++++++++++++++
 3 files changed, 1759 insertions(+), 1 deletion(-)
 create mode 100644 arch/arm/boot/dts/imx6ul-r1701-hpp.dts
 create mode 100644 arch/arm/boot/dts/imx6ul-r1701-mpp.dts

diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 9dfad2cf1135..bb8a5f92666e 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -577,7 +577,9 @@ dtb-$(CONFIG_SOC_IMX6UL) += \
 	imx6ul-ccimx6ulstarter.dtb \
 	imx6ul-ccimx6ulstarter-id129.dtb \
 	imx6ul-ccimx6ulstarter-wb.dtb \
-	imx6ul-ccimx6ulstarter-wb-mfg.dtb
+	imx6ul-ccimx6ulstarter-wb-mfg.dtb \
+	imx6ul-r1701-mpp.dtb \
+	imx6ul-r1701-hpp.dtb
 dtb-$(CONFIG_SOC_IMX6ULL) += \
 	imx6ull-14x14-ddr3-arm2.dtb \
 	imx6ull-14x14-ddr3-arm2-adc.dtb \
diff --git a/arch/arm/boot/dts/imx6ul-r1701-hpp.dts b/arch/arm/boot/dts/imx6ul-r1701-hpp.dts
new file mode 100644
index 000000000000..3c1d5b28610c
--- /dev/null
+++ b/arch/arm/boot/dts/imx6ul-r1701-hpp.dts
@@ -0,0 +1,963 @@
+/*
+ * Copyright 2016, 2017 Digi International, Inc.
+ * Copyright 2017, 2018 HACH Company
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/pwm/pwm.h>
+#include "imx6ul.dtsi"
+#include "imx6ul-ccimx6ul.dtsi"
+
+/ {
+    model = "HQ_HPP";
+    compatible = "hach,r1701", "digi,ccimx6ul", "fsl,imx6ul";
+    hach,machine,name = "r1701";
+
+    // Set boot console output with a stdout-path property
+    chosen {
+        // serial4 = &uart5 for Console FIXED.
+        stdout-path = "serial4:115200n8";
+    };
+
+    // USB 1 - OTG port bus power setting for HOST mode
+    reg_usb_otg1_vbus: reg_usb_otg1:@0 {
+        compatible = "regulator-fixed";
+        regulator-name = "usb_otg1_vbus";
+        regulator-min-microvolt = <5000000>;
+        regulator-max-microvolt = <5000000>;
+        gpio = <&gpio1 4 GPIO_ACTIVE_HIGH>;
+        enable-active-high;
+    };
+
+    // USB 2 - HOST port bus power setting for HOST mode,
+    // NOTE:: Keep GPIO line commented. Our application controls the power line.
+    reg_usb_otg2_vbus: reg_usb_otg2:@0 {
+        compatible = "regulator-fixed";
+        regulator-name = "usb_otg2_vbus";
+        regulator-min-microvolt = <5000000>;
+        regulator-max-microvolt = <5000000>;
+        //gpio = <&gpio2 12 GPIO_ACTIVE_LOW>;
+        enable-active-low;
+    };
+
+    // Color LCD backlight support.
+    lcd_backlight: backlight {
+        compatible = "pwm-backlight";
+        pwms = <&pwm2 0 50000 PWM_POLARITY_INVERTED>;
+
+        // a poor man's way to create a 1:1 relationship between the PWM value and the actual duty cycle
+        brightness-levels = <    0  1  2  3  4  5  6  7  8  9
+                                10 11 12 13 14 15 16 17 18 19
+                                20 21 22 23 24 25 26 27 28 29
+                                30 31 32 33 34 35 36 37 38 39
+                                40 41 42 43 44 45 46 47 48 49
+                                50 51 52 53 54 55 56 57 58 59
+                                60 61 62 63 64 65 66 67 68 69
+                                70 71 72 73 74 75 76 77 78 79
+                                80 81 82 83 84 85 86 87 88 89
+                                90 91 92 93 94 95 96 97 98 99
+                                100
+                            >;
+        default-brightness-level = <50>;
+        status = "disabled";
+    };
+
+    // PXP system - MXC PxP V4L2 driver (CONFIG_VIDEO_MXC_PXP_V4L2) - Color LCD related property
+    pxp_v4l2: pxp-v4l2 {
+        compatible = "fsl,imx6ul-pxp-v4l2", "fsl,imx6sx-pxp-v4l2", "fsl,imx6sl-pxp-v4l2";
+        status = "disabled";
+    };
+
+    // Gpio based matrix Keyboard
+    matrix_keypad: matrix-keypad@0 {
+        compatible = "gpio-matrix-keypad";
+
+        col-gpios = <
+                        &gpio1 15 GPIO_ACTIVE_LOW
+                        &gpio1 10 GPIO_ACTIVE_LOW
+                        &gpio1 11 GPIO_ACTIVE_LOW
+                    >;
+        row-gpios = <
+                        &gpio1 12 GPIO_ACTIVE_HIGH
+                        &gpio1 13 GPIO_ACTIVE_HIGH
+                        &gpio1 14 GPIO_ACTIVE_HIGH
+                    >;
+
+        // Actual MATRIX keys MAP formation based on ROWS and COLUMNS on r1701 keypad hardware
+        //            COL_1           COL_2               COL_3
+        // --------------||--------------||------------------||------------
+        //       ||      ||              ||                  ||
+        // ROW_1 ------ HOME ---------- Left  ---------- <Not Assigned> ---
+        //       ||      ||              ||                  ||
+        // ROW_2 ------- UP  ---------- ENTER ------------- DOWN ----------
+        //       ||      ||              ||                  ||
+        // ROW_3 ------ BACK ---------- RIGHT ---------- <Not Assigned> ---
+        //       ||      ||              ||                  ||
+        // --------------||--------------||--------------------------------
+        //
+        // key assignment MACRO definition - MATRIX_KEY(row, col, code)
+        linux,keymap =  <
+                            MATRIX_KEY(0,   0,  KEY_HOME)
+                            MATRIX_KEY(0,   1,  KEY_LEFT)
+                            MATRIX_KEY(1,   0,  KEY_UP)
+                            MATRIX_KEY(1,   1,  KEY_ENTER)
+                            MATRIX_KEY(1,   2,  KEY_DOWN)
+                            MATRIX_KEY(2,   0,  KEY_BACKSPACE)
+                            MATRIX_KEY(2,   1,  KEY_RIGHT)
+                        >;
+
+        // Debounce time and column scan time can be adjusted based on our need.
+        debounce-delay-ms = <10>;
+        col-scan-delay-us = <100>;
+    };
+
+    // V5P0_EN Power regulator - enabled at boot time for MIP display support as well probe, audio etc.
+    reg_V5P0_EN: regulator-V5P0_EN {
+        compatible = "regulator-fixed";
+        regulator-name = "V5P0_EN";
+        regulator-min-microvolt = <3300000>;
+        regulator-max-microvolt = <3300000>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_V5P0_EN_power>;
+        gpio = <&gpio5 6 GPIO_ACTIVE_HIGH>;
+        enable-active-high;
+        regulator-boot-on;
+        regulator-always-on;
+
+        // When power off key is pressed, system will enter in to suspend mode and we do not want this 5V power on.
+        regulator-state-mem {
+            regulator-off-in-suspend;
+        };
+    };
+};
+
+// We are not using MCA UART, delete that node from device tree definition.
+/delete-node/ &mca_uart;
+
+// We are not using MCA temper detection logic and it's associated features. Delete this node definition.
+/delete-node/ &mca_tamper;
+
+// NAND
+&gpmi {
+    // Default is "fsl,imx6q-gpmi-nand" defined in imx6ul.dtsi file, however we use imx6ul, so lets add this property
+    compatible = "fsl,imx6ul-gpmi-nand";
+
+    // boolean to enable on flash bbt (bad block table) option if not present false
+    nand-on-flash-bbt;
+
+    // ECC mode - operation mode of the NAND ecc mode. Supported values are: "none", "soft", "hw", "hw_syndrome",
+    // "hw_oob_first", "on-die".
+    nand-ecc-mode = "hw";
+
+    // algorithm of NAND ECC. Supported values are: "hamming", "bch".
+    nand-ecc-algo = "bch";
+
+    status = "okay";
+};
+
+// Power key - This node defines settings for the power key associated with the MCA. Refer to binding at,
+// "Documentation/devicetree/bindings/input/digi,mca-cc6ul-powerkey.txt"
+&mca_cc6ul{
+    pwrkey {
+        compatible = "digi,mca-cc6ul-pwrkey";
+
+        // enable the KEY_POWER events. We do not want MCA to post ACPI power off event to kernel. We will detect this
+        // key detection in our application and then will initiate graceful shutdown event. "/delete-property/"
+        digi,key-power;
+
+        // enable the KEY_SLEEP events
+        digi,key-sleep;
+
+        // Number of ms that the input/Key must be stable (low level) in order to be considered valid.
+        digi,debounce-ms = <100>;
+
+        // number of seconds that the Power Key must be pressed to generate a KEY_POWER event.
+        digi,pwroff-delay-sec = <5>;
+
+        // time that the MCA will wait for the OS to power off the system. After that the MCA will switch it off.
+        digi,pwroff-guard-sec = <30>;
+    };
+};
+
+// PMIC - SW1A --> Powers several interfaces inside the module
+&int_3v3 {
+    regulator-min-microvolt = <700000>;
+    regulator-max-microvolt = <3300000>;
+    regulator-ramp-delay = <6250>;
+    regulator-boot-on;
+    regulator-always-on;
+    regulator-state-mem {
+        regulator-off-in-suspend;
+    };
+};
+
+// PMIC - SW1B --> Internal CPU power supply
+&vdd_arm_soc_in {
+    regulator-min-microvolt = <700000>;
+    regulator-max-microvolt = <1475000>;
+    regulator-ramp-delay = <6250>;
+    regulator-boot-on;
+    regulator-always-on;
+    regulator-state-mem {
+        regulator-on-in-suspend;
+        regulator-suspend-microvolt = <925000>;
+    };
+};
+
+// PMIC - SW2 --> DBuck regulator, Default 3.3 VDC, SOM_3V3_EXT
+&ext_3v3 {
+    regulator-min-microvolt = <2500000>;
+    regulator-max-microvolt = <3300000>;
+    regulator-ramp-delay = <6250>;
+    regulator-always-on;
+    regulator-boot-on;
+    regulator-state-mem {
+        regulator-off-in-suspend;
+    };
+};
+
+// PMIC - SW3 --> DDR3 power supply
+&vcc_ddr3 {
+    regulator-min-microvolt = <900000>;
+    regulator-max-microvolt = <1650000>;
+    regulator-always-on;
+    regulator-boot-on;
+    regulator-state-mem {
+        regulator-on-in-suspend;
+        regulator-suspend-microvolt = <1300000>;
+    };
+};
+
+// PMIC - SWBST --> Boost regulator, default 5VDC
+&swbst_reg {
+    regulator-min-microvolt = <5000000>;
+    regulator-max-microvolt = <5150000>;
+};
+
+// PMIC - VSNVS --> Internal CPU power supply
+&vdd_snvs_3v3 {
+    regulator-min-microvolt = <1000000>;
+    regulator-max-microvolt = <3000000>;
+    regulator-boot-on;
+    regulator-always-on;
+};
+
+// PMIC - VREFDDR --> DDR reference voltage
+&vrefddr {
+    regulator-boot-on;
+    regulator-always-on;
+};
+
+// PMIC - LDO1 --> CPU ADC reference voltage
+&vdda_adc_3v3 {
+    compatible = "regulator-fixed";
+    regulator-name = "vref-adc-3v3";
+    regulator-min-microvolt = <3300000>;
+    regulator-max-microvolt = <3300000>;
+    regulator-always-on;
+    regulator-state-mem {
+        regulator-off-in-suspend;
+    };
+};
+
+// PMIC - LDO2 --> LDO regulator, 1.5VDC  - TP13
+&ldo2_ext {
+    regulator-min-microvolt = <800000>;
+    regulator-max-microvolt = <1550000>;
+    regulator-state-mem {
+        regulator-off-in-suspend;
+    };
+};
+
+// PMIC - VCC_SD --> Wireless chip power supply
+&vdda_wlan {
+    regulator-min-microvolt = <2850000>;
+    regulator-max-microvolt = <3300000>;
+    regulator-always-on;
+    regulator-boot-on;
+    regulator-state-mem {
+        regulator-off-in-suspend;
+    };
+};
+
+// PMIC - V33 --> Internal CPU power supply
+&vdd_high_in {
+    regulator-min-microvolt = <2850000>;
+    regulator-max-microvolt = <3300000>;
+    regulator-boot-on;
+    regulator-always-on;
+};
+
+// Internal to SOM, Do not change any property in this node
+&ldo3_int {
+    regulator-min-microvolt = <1800000>;
+    regulator-max-microvolt = <3300000>;
+};
+
+// PMIC - LDO4 --> LDO regulator, 1.8 VDC, Powers the Voltage shifter chips for LCD display, TP14
+// DO NOT CHANGE MIN AND MAX VOLTAGE FOR THIS LDO. THIS LDO MUST PROVIDE ONLY 1.8VDC. This voltage is given to color
+// LCD and if it is more than 1.8VDC then it will damange LCD.
+&ldo4_ext {
+    regulator-min-microvolt = <1800000>;
+    regulator-max-microvolt = <1800000>;
+    regulator-state-mem {
+        regulator-off-in-suspend;
+    };
+};
+
+// PMIC - VCOIN --> Coin cell charger, 3 VDC
+&vcoin_chg {
+    regulator-min-microvolt = <2500000>;
+    regulator-max-microvolt = <3300000>;
+};
+
+// CAAM (Cryptographic Accelerator and Assurance Module), The i.MX6 processors offer hardware encryption through NXP's
+// Cryptographic Accelerator and Assurance Module (CAAM, also known as SEC4). The CAAM combines functions to create a
+// modular and scalable acceleration and assurance engine.
+// See this link - "https://www.digi.com/resources/documentation/digidocs/90001546/reference/android/r_caam_android.htm"
+// NOTE - Disable this module if not needed.
+&caam_keyblob {
+    status = "disabled";
+};
+
+// MCA IO3 & IO4 connected as ADC, it is defined under i2c1 node in imx6ul-ccimx6ul.dtsi file.
+&mca_adc {
+    compatible = "digi,mca-cc6ul-adc";
+
+    // Channel 1 - HDWR_REV_ADC
+    // Channel 3 - BLEMOD_ID_ADC
+    // Channel 4 - LITH_BAT_ADC
+    // Channel 5 - REF_V2P5
+    digi,adc-ch-list = <1 3 4 5>;
+
+    // ADC reference voltage. Use:
+    //   - digi,adc-vref: Value in uV that corresponds with the VCC_MCA voltage.
+    //   - digi,internal-vref: If present, the internal 1.2 V reference is used.
+    //     This forces MCA_IO2/EXT_VREF to be configured as a 1.2 V output, and a
+    //     100 nF capacitor must be placed between this line and GND.
+    //     If this property is set, the value in 'digi,adc-vref' is ignored.
+    digi,adc-vref = <3300000>;
+};
+
+// Ethernet
+&fec1 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_enet1>;
+    phy-mode = "rmii";
+    phy-reset-gpios = <&mca_gpio 7 GPIO_ACTIVE_LOW>;
+    phy-reset-duration = <50>;
+    phy-handle = <&ethphy0>;
+
+    // keeps the phy in reset during suspend mode to avoid back-drives through the reset line.
+    digi,phy-reset-in-suspend;
+    status = "okay";
+
+    mdio {
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        ethphy0: ethernet-phy@0 {
+            compatible = "ethernet-phy-ieee802.3-c22";
+            smsc,disable-energy-detect;
+            reg = <0>;
+        };
+    };
+};
+
+// UART5 (Console)
+&uart5 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_uart5>;
+    status = "okay";
+};
+
+// Probe - 1
+&uart3 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_uart3>;
+    uart-has-rtscts;
+    rs485-rts-active-high;
+    rs485-rx-during-tx;
+    rs485-rts-delay = <1 1>;
+    linux,rs485-enabled-at-boot-time;
+    status = "okay";
+};
+
+// Probe - 2
+&uart1 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_uart1>;
+    uart-has-rtscts;
+    rs485-rts-active-high;
+    rs485-rx-during-tx;
+    rs485-rts-delay = <1 1>;
+    linux,rs485-enabled-at-boot-time;
+    status = "okay";
+};
+
+// Probe - 3
+&uart8 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_uart8>;
+    uart-has-rtscts;
+    rs485-rts-active-high;
+    rs485-rx-during-tx;
+    rs485-rts-delay = <1 1>;
+    linux,rs485-enabled-at-boot-time;
+    status = "okay";
+};
+
+// BLE Module
+&uart6 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_uart6>;
+    status = "okay";
+};
+
+// USDHC2 (microSD)
+&usdhc2 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_usdhc2>;
+
+    // Number of data lines, can be <1>, <4>, or <8>.  The default will be <1> if the property is absent.
+    bus-width = <4>;
+
+    // There is no card detection available; polling must be used.
+    broken-cd;
+
+    // Denotes that 1.8v card voltage is not supported on this system, even if the controller claims it is.
+    no-1-8-v;
+
+    status = "okay";
+};
+
+// SPI port for MIP display (MPP Only)
+&ecspi1 {
+    status      = "disabled";
+};
+
+// Pressure chip
+&ecspi3 {
+    fsl,spi-num-chipselects = <1>;
+    cs-gpios = <&gpio1 2 GPIO_ACTIVE_LOW>;
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_ecspi3_master>;
+    status = "okay";
+
+    /* MS5607-02BA03 # Barometric Pressure Sensor */
+    pressureSensor: ecspi@0 {
+        compatible = "meas,ms5607";
+        reg = <0>;
+        spi-max-frequency = <1000000>;
+        status = "okay";
+    };
+};
+
+// AUDIO Module (Beeper)
+&pwm1 {
+    pinctrl-names = "default","pwm";
+    pinctrl-0 = <&pinctrl_pwm1_gpio>;
+    pinctrl-1 = <&pinctrl_pwm1_pwm>;
+    clocks =    <&clks IMX6UL_CLK_PWM1>,
+                <&clks IMX6UL_CLK_PWM1>;
+    status = "okay";
+};
+
+// Color LCD backlight PWM
+&pwm2 {
+    pinctrl-names = "default","pwm";
+    pinctrl-0 = <&pinctrl_pwm2_gpio>;
+    pinctrl-1 = <&pinctrl_pwm2_pwm>;
+    clocks =    <&clks IMX6UL_CLK_PWM2>,
+    <&clks IMX6UL_CLK_PWM2>;
+    status = "okay";
+};
+
+/* All PWM channels are not disabled by default in main imx6ul.dtsi file, hence disable them all here if not used */
+&pwm3 {
+    status = "disabled";
+};
+
+&pwm4 {
+    status = "disabled";
+};
+
+&pwm5 {
+    status = "disabled";
+};
+
+&pwm6 {
+    status = "disabled";
+};
+
+&pwm7 {
+    status = "disabled";
+};
+
+&pwm8 {
+    status = "disabled";
+};
+
+// Battery Charger Chip
+&i2c3 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default", "gpio";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	pinctrl-1 = <&pinctrl_i2c3_gpio>;
+	scl-gpios = <&gpio2 8 GPIO_ACTIVE_HIGH>;
+	sda-gpios = <&gpio2 9 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+
+    // Refer - https://www.kernel.org/doc/Documentation/devicetree/bindings/power/supply/bq25890.txt
+    batteryCharger: bq25890@6A {
+
+        compatible = "ti,bq25890";
+        reg = <0x6A>;
+
+        // The INT pin sends active low, 256-µs pulse to host to report charger device status and fault.
+        pinctrl-names = "default";
+  
+        //interrupt-parent = <&mca_gpio>;
+        //interrupts = <6 IRQ_TYPE_EDGE_FALLING>;
+        pinctrl-0 = <&pinctrl_charger_irq>;
+        interrupt-parent = <&gpio4>;
+        interrupts = <26 IRQ_TYPE_EDGE_FALLING>;
+
+        // maximum charging voltage (in uV) - 4.192 VDC
+        ti,battery-regulation-voltage = <4192000>;
+
+        // maximum charging current (in uA) - 1024 mA
+        ti,charge-current = <1024000>;
+
+        // charge will be terminated when current in constant-voltage phase drops below this value (in uA) - 256 mA
+        ti,termination-current = <256000>;
+
+        // maximum charge current during precharge phase (in uA)
+        ti,precharge-current = <128000>;
+
+        // when battery is charging and it is below minimum system voltage, the system will be regulated above
+        // minimum-sys-voltage setting (in uV) - 3.0 VDC
+        ti,minimum-sys-voltage = <3000000>;
+
+        // VBUS voltage level in boost mode (in uV) - 5 VDC
+        ti,boost-voltage = <5000000>;
+
+        // maximum allowed current draw in boost mode (in uA) - 1.2 A
+        ti,boost-max-current = <1200000>;
+
+        // charge timer in hours: 5,8,12 and 20 - 8 hours
+        ti,charge-timer= <8>;
+
+        // IR Compensation Resistor Setting (uOhm) - 0mOhm
+        ti,compensation-resistor= <00000>;
+
+        //IR Compensation Voltage Clamp (uV) - 96mV
+        ti,compensation-voltage= <96000>;
+
+        // Below three settings are Optional properties //
+
+        // if present boost mode frequency will be 500kHz, otherwise 1.5MHz, we want 1.5 MHZ so disable this propert
+        //ti,boost-low-freq;
+
+        // If present the ILIM resistor will be used and the input current will be the lower between the resistor setting
+        // and the IINLIM register setting. We need this property.
+        ti,use-ilim-pin;
+
+        // Temperature above which the charge current is lowered, to avoid overheating (in degrees Celsius). If omitted,
+        // the default setting will be used (120 degrees)
+        ti,thermal-regulation-threshold = <120>;
+    };
+};
+
+// Parallel LCD
+&lcdif {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_lcdif>;
+    gpios = <&gpio5 0  GPIO_ACTIVE_LOW>,    // LCD_PWR_EN&
+            <&gpio3 4  GPIO_ACTIVE_LOW>,    // LCD_RESET&
+            <&gpio5 9  GPIO_ACTIVE_LOW>;    // LCD_STANDBY&
+    display = <&com35h3p29ulc>;
+    lcd-supply = <&ldo4_ext>;
+    status = "okay";
+
+    // 3.5 inch Ortustech - COM35H3P29ULC color VGA portrait display
+    com35h3p29ulc: display@0 {
+
+        // 16 Bit Color mode
+        bits-per-pixel = <16>;
+
+        // number of data lines.  Could be <8>, <16>, <18> or <24>
+        bus-width = <16>;
+
+        // Display panel timning table.
+        display-timings {
+            native-mode = <&timing0>;
+
+            // VGA - Ortustech Display (Portrait Mode)
+            timing0: 480x640 {
+
+                // Pixel clock in Hz 19.8 MHz Typical
+                clock-frequency = <19800000>;
+
+                // display resolution */
+                hactive = <480>;
+                vactive = <640>;
+
+                // HSYNC Cycle (508) = HFP + HBP + HSYNC_LEN + 480
+                hfront-porch = <8>;
+                hback-porch = <10>;
+                hsync-len = <10>;
+
+                // VSYNC Cycle (650) = VFP + VBP + VSYNC_LEN + 640
+                vback-porch = <3>;
+                vfront-porch = <4>;
+                vsync-len = <3>;
+
+                // hsync/vsync pulse is active low/high/ignored */
+                // Ortustech display expect HSYNC and VSYNC as active low for valid data transfer
+                hsync-active = <0>;
+                vsync-active = <0>;
+
+                // data-enable pulse is active low/high/ignored
+                // Ortustech display expect data valid signal as active HIGH
+                de-active = <1>;
+
+                // Pixel Clock,
+                //  - active high = drive pixel data on rising edge sample data on falling edge
+                //  - active low  = drive pixel data on falling edge sample data on rising edge
+                //  - ignored     = ignored
+                //
+                // Ortustech display latch all LCD data on falling edge
+                //
+                pixelclk-active = <1>;
+            };
+        };
+    };
+};
+
+// PXP video module
+&pxp_v4l2 {
+    status = "okay";
+};
+
+&pxp {
+    status = "okay";
+};
+
+// enable backlight
+&lcd_backlight {
+    status = "okay";
+};
+
+// USB - 1 # OTG (Battery Charger port)
+&usbotg1 {
+    dr_mode = "otg";
+    pinctrl-0 = <&pinctrl_usbotg1>;
+    vbus-supply = <&reg_usb_otg1_vbus>;
+    digi,power-line-active-high;
+
+    // We do not have OC detect line on hardware for OTG port
+    disable-over-current;
+    status = "okay";
+};
+
+// USB - 2 # Host
+&usbotg2 {
+    dr_mode = "host";
+
+    /* Keep below code disabled. Somehow imx6ul does not work reliabiliy with these properties enabled. */
+    //pinctrl-0 = <&pinctrl_usbotg2>;
+    //vbus-supply = <&reg_usb_otg2_vbus>;
+    //digi,power-line-active-low;
+    //over-current-active-low;
+
+    disable-over-current;
+    status = "okay";
+};
+
+// Pin mux configuration
+&iomuxc {
+
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_hog>;
+
+    imx6ul-ccimx6ul {
+        // Enable 5 VDC to system from VDC RAW power, Active High Signal
+        pinctrl_V5P0_EN_power: V5P0_EN_power {
+            fsl,pins = <
+                MX6UL_PAD_SNVS_TAMPER6__GPIO5_IO06      0x10b0
+            >;
+        };
+
+        // NAND
+        pinctrl_gpmi_nand: gpmigrp {
+            fsl,pins = <
+                MX6UL_PAD_NAND_CE0_B__RAWNAND_CE0_B     0xf0f1
+                MX6UL_PAD_NAND_RE_B__RAWNAND_RE_B       0xf0f1
+                MX6UL_PAD_NAND_WE_B__RAWNAND_WE_B       0xf0f1
+                MX6UL_PAD_NAND_WP_B__RAWNAND_WP_B       0xf0f1
+                MX6UL_PAD_NAND_ALE__RAWNAND_ALE         0xf0f1
+                MX6UL_PAD_NAND_CLE__RAWNAND_CLE         0xf0f1
+                MX6UL_PAD_NAND_DATA00__RAWNAND_DATA00   0xf0f1
+                MX6UL_PAD_NAND_DATA01__RAWNAND_DATA01   0xf0f1
+                MX6UL_PAD_NAND_DATA02__RAWNAND_DATA02   0xf0f1
+                MX6UL_PAD_NAND_DATA03__RAWNAND_DATA03   0xf0f1
+                MX6UL_PAD_NAND_DATA04__RAWNAND_DATA04   0xf0f1
+                MX6UL_PAD_NAND_DATA05__RAWNAND_DATA05   0xf0f1
+                MX6UL_PAD_NAND_DATA06__RAWNAND_DATA06   0xf0f1
+                MX6UL_PAD_NAND_DATA07__RAWNAND_DATA07   0xf0f1
+                MX6UL_PAD_NAND_READY_B__RAWNAND_READY_B 0xf0f1
+            >;
+        };
+
+        // Ethernet pins
+        pinctrl_enet1: enet1grp {
+            fsl,pins = <
+                MX6UL_PAD_GPIO1_IO07__ENET1_MDC         0x1b0b0
+                MX6UL_PAD_GPIO1_IO06__ENET1_MDIO        0x1b0b0
+                MX6UL_PAD_ENET1_RX_EN__ENET1_RX_EN      0x1b0b0
+                MX6UL_PAD_ENET1_RX_ER__ENET1_RX_ER      0x1b0b0
+                MX6UL_PAD_ENET1_RX_DATA0__ENET1_RDATA00 0x1b0b0
+                MX6UL_PAD_ENET1_RX_DATA1__ENET1_RDATA01 0x1b0b0
+                MX6UL_PAD_ENET1_TX_EN__ENET1_TX_EN      0x1b0b0
+                MX6UL_PAD_ENET1_TX_DATA0__ENET1_TDATA00 0x1b0b0
+                MX6UL_PAD_ENET1_TX_DATA1__ENET1_TDATA01 0x1b0b0
+                MX6UL_PAD_ENET1_TX_CLK__ENET1_REF_CLK1  0x40017051
+            >;
+        };
+
+        // Probe - 1 UART
+        pinctrl_uart3: uart3grp {
+            fsl,pins = <
+                MX6UL_PAD_UART3_RX_DATA__UART3_DCE_RX   0x1b0b1
+                MX6UL_PAD_UART3_TX_DATA__UART3_DCE_TX   0x1b0b1
+                MX6UL_PAD_UART3_RTS_B__UART3_DCE_RTS    0x1b0b1
+                MX6UL_PAD_UART3_CTS_B__UART3_DCE_CTS    0x1b0b1
+            >;
+        };
+
+        // Probe - 2 UART
+        pinctrl_uart1: uart1grp {
+            fsl,pins = <
+                MX6UL_PAD_UART1_RX_DATA__UART1_DCE_RX   0x1b0b1
+                MX6UL_PAD_UART1_TX_DATA__UART1_DCE_TX   0x1b0b1
+                MX6UL_PAD_UART1_RTS_B__UART1_DCE_RTS    0x1b0b1
+                MX6UL_PAD_UART1_CTS_B__UART1_DCE_CTS    0x1b0b1
+            >;
+        };
+
+        // Probe - 3 UART
+        pinctrl_uart8: uart8grp {
+            fsl,pins = <
+                MX6UL_PAD_LCD_DATA21__UART8_DCE_RX      0x1b0b1
+                MX6UL_PAD_LCD_DATA20__UART8_DCE_TX      0x1b0b1
+                MX6UL_PAD_ENET2_RX_ER__UART8_DCE_RTS    0x1b0b1
+                MX6UL_PAD_ENET2_TX_CLK__UART8_DCE_CTS   0x1b0b1
+            >;
+        };
+
+        // BLE Module
+        pinctrl_uart6: uart6grp {
+            fsl,pins = <
+                MX6UL_PAD_CSI_PIXCLK__UART6_DCE_RX      0x1b0b1
+                MX6UL_PAD_CSI_MCLK__UART6_DCE_TX        0x1b0b1
+            >;
+        };
+
+        // Console UART pins
+        pinctrl_uart5: uart5grp {
+            fsl,pins = <
+                MX6UL_PAD_UART5_TX_DATA__UART5_DCE_TX   0x1b0b1
+                MX6UL_PAD_UART5_RX_DATA__UART5_DCE_RX   0x1b0b1
+            >;
+        };
+
+        // micro SD card peripheral port pins
+        pinctrl_usdhc2: usdhc2grp {
+            fsl,pins = <
+                MX6UL_PAD_CSI_VSYNC__USDHC2_CLK         0x10039
+                MX6UL_PAD_CSI_HSYNC__USDHC2_CMD         0x17059
+                MX6UL_PAD_CSI_DATA00__USDHC2_DATA0      0x17059
+                MX6UL_PAD_CSI_DATA01__USDHC2_DATA1      0x17059
+                MX6UL_PAD_CSI_DATA02__USDHC2_DATA2      0x17059
+                MX6UL_PAD_CSI_DATA03__USDHC2_DATA3      0x17059
+            >;
+        };
+
+        // SPI 1 - MIP display
+        pinctrl_ecspi1_master: ecspi1grp1 {
+            fsl,pins = <
+                MX6UL_PAD_LCD_DATA22__ECSPI1_MOSI       0x10b0
+                MX6UL_PAD_LCD_DATA23__ECSPI1_MISO       0x10b0
+                MX6UL_PAD_CSI_DATA04__ECSPI1_SCLK       0x10b0
+                MX6UL_PAD_GPIO1_IO03__GPIO1_IO03        0x30b0
+            >;
+        };
+
+        // SPI 3 - Pressure sensor chip
+        pinctrl_ecspi3_master: ecspi3grp1 {
+            fsl,pins = <
+                MX6UL_PAD_UART2_CTS_B__ECSPI3_MOSI      0x10b0
+                MX6UL_PAD_UART2_RTS_B__ECSPI3_MISO      0x10b0
+                MX6UL_PAD_UART2_RX_DATA__ECSPI3_SCLK    0x10b0
+                MX6UL_PAD_GPIO1_IO02__GPIO1_IO02        0x10b0
+            >;
+        };
+
+        // USB 1 OTG port pins (Battery Charger)
+        pinctrl_usbotg1: usbotg1grp {
+            fsl,pins = <
+                MX6UL_PAD_GPIO1_IO00__ANATOP_OTG1_ID    0x17059
+                MX6UL_PAD_GPIO1_IO04__GPIO1_IO04        0x17059
+            >;
+        };
+
+        // USB 2 HOST port pins (Battery Compartment) - DO NOT ENABLE THIS BLOCK.
+        // pinctrl_usbotg2: usbotg2grp {
+        //     fsl,pins = <
+        //         MX6UL_PAD_ENET2_TX_EN__USB_OTG2_OC      0x17059
+        //         MX6UL_PAD_ENET2_TX_DATA1__GPIO2_IO12    0x17059
+        //     >;
+        // };
+
+        // AUDIO PWM - Beeper
+        pinctrl_pwm1_pwm: pwm1grp-pwm {
+            fsl,pins = <
+                MX6UL_PAD_GPIO1_IO08__PWM1_OUT          0x110b0
+            >;
+        };
+       pinctrl_pwm1_gpio: pwm1grp-gpio {
+            fsl,pins = <
+                MX6UL_PAD_GPIO1_IO08__GPIO1_IO08          0x130b0
+            >;
+        };
+        // Color LCD back light control signal
+        pinctrl_pwm2_pwm: pwm2grp-pwm {
+            fsl,pins = <
+                MX6UL_PAD_GPIO1_IO09__PWM2_OUT          0x110b0
+            >;
+        };
+        pinctrl_pwm2_gpio: pwm2grp-gpio {
+            fsl,pins = <
+                MX6UL_PAD_GPIO1_IO09__GPIO1_IO09          0x1f0b0
+           >;
+       };
+
+        // Battery Charger Chip - I2C Bus definition.
+        pinctrl_i2c3: i2c3grp {
+            fsl,pins = <
+                MX6UL_PAD_ENET2_RX_DATA0__I2C3_SCL      0x4001b8b0
+                MX6UL_PAD_ENET2_RX_DATA1__I2C3_SDA      0x4001b8b0
+            >;
+        };
+        /* Battery Charger IRQ - Active Low Signal */
+        pinctrl_charger_irq: chargerIrq {
+            fsl,pins = <
+                MX6UL_PAD_CSI_DATA05__GPIO4_IO26        0x10b0
+            >;
+        };
+		// Battery Charger Chip - I2C Bus as GPIO definition.
+		pinctrl_i2c3_gpio: i2c3gpiogrp {
+			fsl,pins = <
+				MX6UL_PAD_ENET2_RX_DATA0__GPIO2_IO08	0x1b0b0
+				MX6UL_PAD_ENET2_RX_DATA1__GPIO2_IO09	0x1b0b0
+			>;
+		};
+
+        // Ortustech VGA LCD pins
+        pinctrl_lcdif: lcdifdatactrlgrp {
+            fsl,pins = <
+                MX6UL_PAD_LCD_DATA00__LCDIF_DATA00      0x79
+                MX6UL_PAD_LCD_DATA01__LCDIF_DATA01      0x79
+                MX6UL_PAD_LCD_DATA02__LCDIF_DATA02      0x79
+                MX6UL_PAD_LCD_DATA03__LCDIF_DATA03      0x79
+                MX6UL_PAD_LCD_DATA04__LCDIF_DATA04      0x79
+                MX6UL_PAD_LCD_DATA05__LCDIF_DATA05      0x79
+                MX6UL_PAD_LCD_DATA06__LCDIF_DATA06      0x79
+                MX6UL_PAD_LCD_DATA07__LCDIF_DATA07      0x79
+                MX6UL_PAD_LCD_DATA08__LCDIF_DATA08      0x79
+                MX6UL_PAD_LCD_DATA09__LCDIF_DATA09      0x79
+                MX6UL_PAD_LCD_DATA10__LCDIF_DATA10      0x79
+                MX6UL_PAD_LCD_DATA11__LCDIF_DATA11      0x79
+                MX6UL_PAD_LCD_DATA12__LCDIF_DATA12      0x79
+                MX6UL_PAD_LCD_DATA13__LCDIF_DATA13      0x79
+                MX6UL_PAD_LCD_DATA14__LCDIF_DATA14      0x79
+                MX6UL_PAD_LCD_DATA15__LCDIF_DATA15      0x79
+                MX6UL_PAD_LCD_ENABLE__LCDIF_ENABLE      0x79
+                MX6UL_PAD_LCD_HSYNC__LCDIF_HSYNC        0x79
+                MX6UL_PAD_LCD_VSYNC__LCDIF_VSYNC        0x79
+                MX6UL_PAD_LCD_CLK__LCDIF_CLK            0x17050
+            >;
+        };
+
+        // General purpose pinctrl
+        pinctrl_hog: hoggrp {
+            fsl,pins = <
+                // Column (strobe) lines as outputs - Active low signals
+                MX6UL_PAD_JTAG_TRST_B__GPIO1_IO15       0x10b0  // KEYPAD_COL1
+                MX6UL_PAD_JTAG_MOD__GPIO1_IO10          0x10b0  // KEYPAD_COL2
+                MX6UL_PAD_JTAG_TMS__GPIO1_IO11          0x10b0  // KEYPAD_COL3
+
+                // Row lines as inputs, active high signals
+                MX6UL_PAD_JTAG_TDO__GPIO1_IO12          0x10b0  // KEYPAD_ROW1
+                MX6UL_PAD_JTAG_TDI__GPIO1_IO13          0x10b0  // KEYPAD_ROW2
+                MX6UL_PAD_JTAG_TCK__GPIO1_IO14          0x10b0  // KEYPAD_ROW3
+
+                // SD card control lines, Active low signals
+                MX6UL_PAD_SNVS_TAMPER7__GPIO5_IO07      0x10b0  // SDCARD_PWR&
+
+                // MIP Display, Active high signals
+                MX6UL_PAD_SNVS_TAMPER8__GPIO5_IO08      0x3031  // SER_LCD_EXTCOM
+                MX6UL_PAD_SNVS_TAMPER1__GPIO5_IO01      0x3031  // SER_LCD_ON_OFF
+                MX6UL_PAD_SNVS_TAMPER5__GPIO5_IO05      0x3031  // SER_LCD_BKLT_EN
+
+                // Probe 1 - Control lines
+                MX6UL_PAD_UART2_TX_DATA__GPIO1_IO20     0xb0b0  // PRB1_DET&
+                MX6UL_PAD_LCD_DATA17__GPIO3_IO22        0x10b0  // PRB1_OFF
+                MX6UL_PAD_GPIO1_IO01__GPIO1_IO01        0x10b0  // PRB1_EN&
+
+                // Probe 2 - Control lines
+                MX6UL_PAD_ENET2_TX_DATA0__GPIO2_IO11    0xb0b0  // PRB2_DET&
+                MX6UL_PAD_LCD_DATA18__GPIO3_IO23        0x10b0  // PRB2_OFF
+                MX6UL_PAD_ENET2_RX_EN__GPIO2_IO10       0x10b0  // PRB2_EN&
+
+                // Probe 3 - Control lines
+                MX6UL_PAD_SD1_CLK__GPIO2_IO17           0xb0b0  // PRB3_DET&
+                MX6UL_PAD_LCD_DATA19__GPIO3_IO24        0x10b0  // PRB3_OFF
+                MX6UL_PAD_SD1_CMD__GPIO2_IO16           0x10b0  // PRB3_EN&
+
+                // BLE Module
+                MX6UL_PAD_SD1_DATA0__GPIO2_IO18         0x10b0  // BLEMOD_PWR*
+                MX6UL_PAD_SD1_DATA2__GPIO2_IO20         0x10b0  // BLE_MOD_READ_ID*
+                MX6UL_PAD_SD1_DATA3__GPIO2_IO21         0x10b0  // BLEMOD_WAKEUP*
+
+                // LCD Module
+                MX6UL_PAD_LCD_RESET__GPIO3_IO04         0x10b0  // LCD_RESET&
+                MX6UL_PAD_SNVS_TAMPER9__GPIO5_IO09      0x10b0  // LCD2_STANDBY&
+                MX6UL_PAD_SNVS_TAMPER0__GPIO5_IO00      0x10b0  // LCD2_PWR_EN&
+
+                // Ethernet control lines
+                MX6UL_PAD_CSI_DATA06__GPIO4_IO27        0x10b0  // ENET1_INT&
+                MX6UL_PAD_CSI_DATA07__GPIO4_IO28        0x10b0  // ENET1_PWR&
+
+                // PWR_ON_OFF_C - Input line
+                MX6UL_PAD_SNVS_TAMPER2__GPIO5_IO02      0x10b0  // PWR_ON_OFF_C
+
+                MX6UL_PAD_SD1_DATA1__GPIO2_IO19         0x10b0  // CHRGR_PRESENT
+
+                MX6UL_PAD_GPIO1_IO05__GPIO1_IO05        0x10b0  // SPARE_W1_TP65
+                MX6UL_PAD_LCD_DATA16__GPIO3_IO21        0x10b0  // SPARE_W10_TP1
+                MX6UL_PAD_NAND_DQS__GPIO4_IO16          0x10b0  // SPARE_M2_TP27
+            >;
+        };
+    };
+};
diff --git a/arch/arm/boot/dts/imx6ul-r1701-mpp.dts b/arch/arm/boot/dts/imx6ul-r1701-mpp.dts
new file mode 100644
index 000000000000..5e2bece5a17e
--- /dev/null
+++ b/arch/arm/boot/dts/imx6ul-r1701-mpp.dts
@@ -0,0 +1,810 @@
+/*
+ * Copyright 2016, 2017 Digi International, Inc.
+ * Copyright 2017, 2018 HACH Company
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/dts-v1/;
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/pwm/pwm.h>
+#include "imx6ul.dtsi"
+#include "imx6ul-ccimx6ul.dtsi"
+
+/ {
+    model = "HQ_MPP";
+    compatible = "hach,r1701", "digi,ccimx6ul", "fsl,imx6ul";
+    hach,machine,name = "r1701";
+
+    // Set boot console output with a stdout-path property
+    chosen {
+        // serial4 = &uart5 for Console FIXED.
+        stdout-path = "serial4:115200n8";
+    };
+
+    // USB 1 - OTG port bus power setting for HOST mode
+    reg_usb_otg1_vbus: reg_usb_otg1:@0 {
+        compatible = "regulator-fixed";
+        regulator-name = "usb_otg1_vbus";
+        regulator-min-microvolt = <5000000>;
+        regulator-max-microvolt = <5000000>;
+        gpio = <&gpio1 4 GPIO_ACTIVE_HIGH>;
+        enable-active-high;
+    };
+
+    // Gpio based matrix Keyboard
+    matrix_keypad: matrix-keypad@0 {
+        compatible = "gpio-matrix-keypad";
+
+        col-gpios = <
+                        &gpio1 15 GPIO_ACTIVE_LOW
+                        &gpio1 10 GPIO_ACTIVE_LOW
+                        &gpio1 11 GPIO_ACTIVE_LOW
+                    >;
+        row-gpios = <
+                        &gpio1 12 GPIO_ACTIVE_HIGH
+                        &gpio1 13 GPIO_ACTIVE_HIGH
+                        &gpio1 14 GPIO_ACTIVE_HIGH
+                    >;
+
+        // Actual MATRIX keys MAP formation based on ROWS and COLUMNS on r1701 keypad hardware
+        //            COL_1           COL_2               COL_3
+        // --------------||--------------||------------------||------------
+        //       ||      ||              ||                  ||
+        // ROW_1 ------ HOME ---------- Left  ---------- <Not Assigned> ---
+        //       ||      ||              ||                  ||
+        // ROW_2 ------- UP  ---------- ENTER ------------- DOWN ----------
+        //       ||      ||              ||                  ||
+        // ROW_3 ------ BACK ---------- RIGHT ---------- <Not Assigned> ---
+        //       ||      ||              ||                  ||
+        // --------------||--------------||--------------------------------
+        //
+        // key assignment MACRO definition - MATRIX_KEY(row, col, code)
+        linux,keymap =  <
+                            MATRIX_KEY(0,   0,  KEY_HOME)
+                            MATRIX_KEY(0,   1,  KEY_LEFT)
+                            MATRIX_KEY(1,   0,  KEY_UP)
+                            MATRIX_KEY(1,   1,  KEY_ENTER)
+                            MATRIX_KEY(1,   2,  KEY_DOWN)
+                            MATRIX_KEY(2,   0,  KEY_BACKSPACE)
+                            MATRIX_KEY(2,   1,  KEY_RIGHT)
+                        >;
+
+        // Debounce time and column scan time can be adjusted based on our need.
+        debounce-delay-ms = <10>;
+        col-scan-delay-us = <100>;
+    };
+
+    // V5P0_EN Power regulator - enabled at boot time for MIP display support as well probe, audio etc.
+    reg_V5P0_EN: regulator-V5P0_EN {
+        compatible = "regulator-fixed";
+        regulator-name = "V5P0_EN";
+        regulator-min-microvolt = <3300000>;
+        regulator-max-microvolt = <3300000>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&pinctrl_V5P0_EN_power>;
+        gpio = <&gpio5 6 GPIO_ACTIVE_HIGH>;
+        enable-active-high;
+        regulator-boot-on;
+        regulator-always-on;
+
+        // When power off key is pressed, system will enter in to suspend mode and we do not want this 5V power on.
+        regulator-state-mem {
+            regulator-off-in-suspend;
+        };
+    };
+};
+
+// We are not using MCA UART, delete that node from device tree definition.
+/delete-node/ &mca_uart;
+
+// We are not using MCA temper detection logic and it's associated features. Delete this node definition.
+/delete-node/ &mca_tamper;
+
+// NAND
+&gpmi {
+    // Default is "fsl,imx6q-gpmi-nand" defined in imx6ul.dtsi file, however we use imx6ul, so lets add this property
+    compatible = "fsl,imx6ul-gpmi-nand";
+
+    // boolean to enable on flash bbt (bad block table) option if not present false
+    nand-on-flash-bbt;
+
+    // ECC mode - operation mode of the NAND ecc mode. Supported values are: "none", "soft", "hw", "hw_syndrome",
+    // "hw_oob_first", "on-die".
+    nand-ecc-mode = "hw";
+
+    // algorithm of NAND ECC. Supported values are: "hamming", "bch".
+    nand-ecc-algo = "bch";
+
+    status = "okay";
+};
+
+// Power key - This node defines settings for the power key associated with the MCA. Refer to binding at,
+// "Documentation/devicetree/bindings/input/digi,mca-cc6ul-powerkey.txt"
+&mca_cc6ul{
+    pwrkey {
+        compatible = "digi,mca-cc6ul-pwrkey";
+
+        // enable the KEY_POWER events. We do not want MCA to post ACPI power off event to kernel. We will detect this
+        // key detection in our application and then will initiate graceful shutdown event. /delete-property/
+        digi,key-power;
+
+        // enable the KEY_SLEEP events
+        digi,key-sleep;
+
+        // Number of ms that the input/Key must be stable (low level) in order to be considered valid.
+        digi,debounce-ms = <100>;
+
+        // number of seconds that the Power Key must be pressed to generate a KEY_POWER event.
+        digi,pwroff-delay-sec = <5>;
+
+        // time that the MCA will wait for the OS to power off the system. After that the MCA will switch it off.
+        digi,pwroff-guard-sec = <30>;
+    };
+};
+
+// PMIC - SW1A --> Powers several interfaces inside the module
+&int_3v3 {
+    regulator-min-microvolt = <700000>;
+    regulator-max-microvolt = <3300000>;
+    regulator-ramp-delay = <6250>;
+    regulator-boot-on;
+    regulator-always-on;
+    regulator-state-mem {
+        regulator-off-in-suspend;
+    };
+};
+
+// PMIC - SW1B --> Internal CPU power supply
+&vdd_arm_soc_in {
+    regulator-min-microvolt = <700000>;
+    regulator-max-microvolt = <1475000>;
+    regulator-ramp-delay = <6250>;
+    regulator-boot-on;
+    regulator-always-on;
+    regulator-state-mem {
+        regulator-on-in-suspend;
+        regulator-suspend-microvolt = <925000>;
+    };
+};
+
+// PMIC - SW2 --> DBuck regulator, Default 3.3 VDC, SOM_3V3_EXT
+&ext_3v3 {
+    regulator-min-microvolt = <2500000>;
+    regulator-max-microvolt = <3300000>;
+    regulator-ramp-delay = <6250>;
+    regulator-always-on;
+    regulator-boot-on;
+    regulator-state-mem {
+        regulator-off-in-suspend;
+    };
+};
+
+// PMIC - SW3 --> DDR3 power supply
+&vcc_ddr3 {
+    regulator-min-microvolt = <900000>;
+    regulator-max-microvolt = <1650000>;
+    regulator-always-on;
+    regulator-boot-on;
+    regulator-state-mem {
+        regulator-on-in-suspend;
+        regulator-suspend-microvolt = <1300000>;
+    };
+};
+
+// PMIC - SWBST --> Boost regulator, default 5VDC
+&swbst_reg {
+    regulator-min-microvolt = <5000000>;
+    regulator-max-microvolt = <5150000>;
+};
+
+// PMIC - VSNVS --> Internal CPU power supply
+&vdd_snvs_3v3 {
+    regulator-min-microvolt = <1000000>;
+    regulator-max-microvolt = <3000000>;
+    regulator-boot-on;
+    regulator-always-on;
+};
+
+// PMIC - VREFDDR --> DDR reference voltage
+&vrefddr {
+    regulator-boot-on;
+    regulator-always-on;
+};
+
+// PMIC - LDO1 --> CPU ADC reference voltage
+&vdda_adc_3v3 {
+    compatible = "regulator-fixed";
+    regulator-name = "vref-adc-3v3";
+    regulator-min-microvolt = <3300000>;
+    regulator-max-microvolt = <3300000>;
+    regulator-always-on;
+    regulator-state-mem {
+        regulator-off-in-suspend;
+    };
+};
+
+// PMIC - LDO2 --> LDO regulator, 1.5VDC  - TP13
+&ldo2_ext {
+    regulator-min-microvolt = <800000>;
+    regulator-max-microvolt = <1550000>;
+    regulator-state-mem {
+        regulator-off-in-suspend;
+    };
+};
+
+// PMIC - VCC_SD --> Wireless chip power supply
+&vdda_wlan {
+    regulator-min-microvolt = <2850000>;
+    regulator-max-microvolt = <3300000>;
+    regulator-always-on;
+    regulator-boot-on;
+    regulator-state-mem {
+        regulator-off-in-suspend;
+    };
+};
+
+// PMIC - V33 --> Internal CPU power supply
+&vdd_high_in {
+    regulator-min-microvolt = <2850000>;
+    regulator-max-microvolt = <3300000>;
+    regulator-boot-on;
+    regulator-always-on;
+};
+
+// Internal to SOM, Do not change any property in this node
+&ldo3_int {
+    regulator-min-microvolt = <1800000>;
+    regulator-max-microvolt = <3300000>;
+};
+
+// PMIC - LDO4 --> LDO regulator, 1.8 VDC, Powers the Voltage shifter chips for LCD display, TP14
+// DO NOT CHANGE MIN AND MAX VOLTAGE FOR THIS LDO. THIS LDO MUST PROVIDE ONLY 1.8VDC. This voltage is given to color
+// LCD and if it is more than 1.8VDC then it will damange LCD.
+&ldo4_ext {
+    regulator-min-microvolt = <1800000>;
+    regulator-max-microvolt = <1800000>;
+    regulator-state-mem {
+        regulator-off-in-suspend;
+    };
+};
+
+// PMIC - VCOIN --> Coin cell charger, 3 VDC
+&vcoin_chg {
+    regulator-min-microvolt = <2500000>;
+    regulator-max-microvolt = <3300000>;
+};
+
+// CAAM (Cryptographic Accelerator and Assurance Module), The i.MX6 processors offer hardware encryption through NXP's
+// Cryptographic Accelerator and Assurance Module (CAAM, also known as SEC4). The CAAM combines functions to create a
+// modular and scalable acceleration and assurance engine.
+// See this link - "https://www.digi.com/resources/documentation/digidocs/90001546/reference/android/r_caam_android.htm"
+// NOTE - Disable this module if not needed.
+&caam_keyblob {
+    status = "disabled";
+};
+
+// MCA IO3 & IO4 connected as ADC, it is defined under i2c1 node in imx6ul-ccimx6ul.dtsi file.
+&mca_adc {
+    compatible = "digi,mca-cc6ul-adc";
+
+    // Channel 1 - HDWR_REV_ADC
+    // Channel 3 - BLEMOD_ID_ADC
+    // Channel 4 - LITH_BAT_ADC
+    // Channel 5 - REF_V2P5
+    digi,adc-ch-list = <1 3 4 5>;
+
+    // ADC reference voltage. Use:
+    //   - digi,adc-vref: Value in uV that corresponds with the VCC_MCA voltage.
+    //   - digi,internal-vref: If present, the internal 1.2 V reference is used.
+    //     This forces MCA_IO2/EXT_VREF to be configured as a 1.2 V output, and a
+    //     100 nF capacitor must be placed between this line and GND.
+    //     If this property is set, the value in 'digi,adc-vref' is ignored.
+    digi,adc-vref = <3300000>;
+};
+
+// Ethernet
+&fec1 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_enet1>;
+    phy-mode = "rmii";
+    phy-reset-gpios = <&mca_gpio 7 GPIO_ACTIVE_LOW>;
+    phy-reset-duration = <50>;
+    phy-handle = <&ethphy0>;
+
+    // keeps the phy in reset during suspend mode to avoid back-drives through the reset line.
+    digi,phy-reset-in-suspend;
+    status = "okay";
+
+    mdio {
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        ethphy0: ethernet-phy@0 {
+            compatible = "ethernet-phy-ieee802.3-c22";
+            smsc,disable-energy-detect;
+            reg = <0>;
+        };
+    };
+};
+
+// UART5 (Console)
+&uart5 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_uart5>;
+    status = "okay";
+};
+
+// Probe - 1
+&uart3 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_uart3>;
+    uart-has-rtscts;
+    rs485-rts-active-high;
+    rs485-rx-during-tx;
+    rs485-rts-delay = <1 1>;
+    linux,rs485-enabled-at-boot-time;
+    status = "okay";
+};
+
+// Probe - 2
+&uart1 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_uart1>;
+    uart-has-rtscts;
+    rs485-rts-active-high;
+    rs485-rx-during-tx;
+    rs485-rts-delay = <1 1>;
+    linux,rs485-enabled-at-boot-time;
+    status = "okay";
+};
+
+// Probe - 3
+&uart8 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_uart8>;
+    uart-has-rtscts;
+    rs485-rts-active-high;
+    rs485-rx-during-tx;
+    rs485-rts-delay = <1 1>;
+    linux,rs485-enabled-at-boot-time;
+    status = "okay";
+};
+
+// BLE Module
+&uart6 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_uart6>;
+    status = "okay";
+};
+
+// USDHC2 (microSD)
+&usdhc2 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_usdhc2>;
+
+    // Number of data lines, can be <1>, <4>, or <8>.  The default will be <1> if the property is absent.
+    bus-width = <4>;
+
+    // There is no card detection available; polling must be used.
+    broken-cd;
+
+    // Denotes that 1.8v card voltage is not supported on this system, even if the controller claims it is.
+    no-1-8-v;
+
+    status = "okay";
+};
+
+// SPI port for MIP display
+&ecspi1 {
+    fsl,spi-num-chipselects = <1>;
+    cs-gpios = <&gpio1 3 GPIO_ACTIVE_HIGH>;
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_ecspi1_master>;
+    status      = "okay";
+
+    // 3.2" Portrait MIP Display
+    mipDisplay: ecspi@0{
+        compatible        = "sharp,ls032b7dd02";
+        reg               = <0>;
+        spi-max-frequency = <2000000>;
+        spi-cs-high;
+        gpios             = <&gpio5 1 GPIO_ACTIVE_HIGH>,  // SER_LCD_ON_OFF
+                            <&gpio5 8 GPIO_ACTIVE_HIGH>;  // SER_LCD_EXTCOM
+        status = "okay";
+    };
+};
+
+// Pressure chip
+&ecspi3 {
+    fsl,spi-num-chipselects = <1>;
+    cs-gpios = <&gpio1 2 GPIO_ACTIVE_LOW>;
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_ecspi3_master>;
+    status = "okay";
+
+    /* MS5607-02BA03 # Barometric Pressure Sensor */
+    pressureSensor: ecspi@0 {
+        compatible = "meas,ms5607";
+        reg = <0>;
+        spi-max-frequency = <1000000>;
+        status = "okay";
+    };
+};
+
+// AUDIO Module (Beeper)
+&pwm1 {
+    pinctrl-names = "default","pwm";
+    pinctrl-0 = <&pinctrl_pwm1_gpio>;
+    pinctrl-1 = <&pinctrl_pwm1_pwm>;
+    clocks =    <&clks IMX6UL_CLK_PWM1>,
+                <&clks IMX6UL_CLK_PWM1>;
+    status = "okay";
+};
+
+// Color LCD backlight PWM - HPP only
+&pwm2 {
+    status = "disabled";
+};
+
+// All PWM channels are not disabled by default in main imx6ul.dtsi file, hence disable them all here if not used
+&pwm3 {
+    status = "disabled";
+};
+
+&pwm4 {
+    status = "disabled";
+};
+
+&pwm5 {
+    status = "disabled";
+};
+
+&pwm6 {
+    status = "disabled";
+};
+
+&pwm7 {
+    status = "disabled";
+};
+
+&pwm8 {
+    status = "disabled";
+};
+
+// Battery Charger Chip
+&i2c3 {
+    clock-frequency = <100000>;
+    pinctrl-names = "default", "gpio";
+    pinctrl-0 = <&pinctrl_i2c3>;
+	pinctrl-1 = <&pinctrl_i2c3_gpio>;
+	scl-gpios = <&gpio2 8 GPIO_ACTIVE_HIGH>;
+	sda-gpios = <&gpio2 9 GPIO_ACTIVE_HIGH>;
+    status = "okay";
+
+    // Refer - https://www.kernel.org/doc/Documentation/devicetree/bindings/power/supply/bq25890.txt
+    batteryCharger: bq25890@6A {
+
+        compatible = "ti,bq25890";
+        reg = <0x6A>;
+
+        // The INT pin sends active low, 256-µs pulse to host to report charger device status and fault.
+        pinctrl-names = "default";
+  
+        //interrupt-parent = <&mca_gpio>;
+        //interrupts = <6 IRQ_TYPE_EDGE_FALLING>;
+        pinctrl-0 = <&pinctrl_charger_irq>;
+        interrupt-parent = <&gpio4>;
+        interrupts = <26 IRQ_TYPE_EDGE_FALLING>;
+
+        // maximum charging voltage (in uV) - 4.192 VDC
+        ti,battery-regulation-voltage = <4192000>;
+
+        // maximum charging current (in uA) - 1024 mA
+        ti,charge-current = <1024000>;
+
+        // charge will be terminated when current in constant-voltage phase drops below this value (in uA) - 256 mA
+        ti,termination-current = <256000>;
+
+        // maximum charge current during precharge phase (in uA)
+        ti,precharge-current = <128000>;
+
+        // when battery is charging and it is below minimum system voltage, the system will be regulated above
+        // minimum-sys-voltage setting (in uV) - 3.0 VDC
+        ti,minimum-sys-voltage = <3000000>;
+
+        // VBUS voltage level in boost mode (in uV) - 5 VDC
+        ti,boost-voltage = <5000000>;
+
+        // maximum allowed current draw in boost mode (in uA) - 1.2 A
+        ti,boost-max-current = <1200000>;
+
+        // charge timer in hours: 5,8,12 and 20 - 8 hours
+        ti,charge-timer= <8>;
+
+        // IR Compensation Resistor Setting (uOhm) - 0mOhm
+        ti,compensation-resistor= <00000>;
+
+        //IR Compensation Voltage Clamp (uV) - 96mV
+        ti,compensation-voltage= <96000>;
+
+        // Below three settings are Optional properties //
+
+        // if present boost mode frequency will be 500kHz, otherwise 1.5MHz, we want 1.5 MHZ so disable this propert
+        //ti,boost-low-freq;
+
+        // If present the ILIM resistor will be used and the input current will be the lower between the resistor setting
+        // and the IINLIM register setting. We need this property.
+        ti,use-ilim-pin;
+
+        // Temperature above which the charge current is lowered, to avoid overheating (in degrees Celsius). If omitted,
+        // the default setting will be used (120 degrees)
+        ti,thermal-regulation-threshold = <120>;
+    };
+};
+
+// Parallel LCD - Only HPP
+&lcdif {
+    status = "disabled";
+};
+&pxp {
+    status = "disabled";
+};
+
+// USB - 1 # OTG (Battery Charger port)
+&usbotg1 {
+    dr_mode = "otg";
+    pinctrl-0 = <&pinctrl_usbotg1>;
+    vbus-supply = <&reg_usb_otg1_vbus>;
+    digi,power-line-active-high;
+
+    // We do not have OC detect line on hardware for OTG port
+    disable-over-current;
+    status = "okay";
+};
+
+// USB - 2 # Host - Only HPP
+&usbotg2 {
+    status = "disabled";
+};
+
+// Pin mux configuration
+&iomuxc {
+
+    pinctrl-names = "default";
+    pinctrl-0 = <&pinctrl_hog>;
+
+    imx6ul-ccimx6ul {
+        // Enable 5 VDC to system from VDC RAW power, Active High Signal
+        pinctrl_V5P0_EN_power: V5P0_EN_power {
+            fsl,pins = <
+                MX6UL_PAD_SNVS_TAMPER6__GPIO5_IO06      0x10b0
+            >;
+        };
+
+        // NAND
+        pinctrl_gpmi_nand: gpmigrp {
+            fsl,pins = <
+                MX6UL_PAD_NAND_CE0_B__RAWNAND_CE0_B     0xf0f1
+                MX6UL_PAD_NAND_RE_B__RAWNAND_RE_B       0xf0f1
+                MX6UL_PAD_NAND_WE_B__RAWNAND_WE_B       0xf0f1
+                MX6UL_PAD_NAND_WP_B__RAWNAND_WP_B       0xf0f1
+                MX6UL_PAD_NAND_ALE__RAWNAND_ALE         0xf0f1
+                MX6UL_PAD_NAND_CLE__RAWNAND_CLE         0xf0f1
+                MX6UL_PAD_NAND_DATA00__RAWNAND_DATA00   0xf0f1
+                MX6UL_PAD_NAND_DATA01__RAWNAND_DATA01   0xf0f1
+                MX6UL_PAD_NAND_DATA02__RAWNAND_DATA02   0xf0f1
+                MX6UL_PAD_NAND_DATA03__RAWNAND_DATA03   0xf0f1
+                MX6UL_PAD_NAND_DATA04__RAWNAND_DATA04   0xf0f1
+                MX6UL_PAD_NAND_DATA05__RAWNAND_DATA05   0xf0f1
+                MX6UL_PAD_NAND_DATA06__RAWNAND_DATA06   0xf0f1
+                MX6UL_PAD_NAND_DATA07__RAWNAND_DATA07   0xf0f1
+                MX6UL_PAD_NAND_READY_B__RAWNAND_READY_B 0xf0f1
+            >;
+        };
+
+        // Ethernet pins
+        pinctrl_enet1: enet1grp {
+            fsl,pins = <
+                MX6UL_PAD_GPIO1_IO07__ENET1_MDC         0x1b0b0
+                MX6UL_PAD_GPIO1_IO06__ENET1_MDIO        0x1b0b0
+                MX6UL_PAD_ENET1_RX_EN__ENET1_RX_EN      0x1b0b0
+                MX6UL_PAD_ENET1_RX_ER__ENET1_RX_ER      0x1b0b0
+                MX6UL_PAD_ENET1_RX_DATA0__ENET1_RDATA00 0x1b0b0
+                MX6UL_PAD_ENET1_RX_DATA1__ENET1_RDATA01 0x1b0b0
+                MX6UL_PAD_ENET1_TX_EN__ENET1_TX_EN      0x1b0b0
+                MX6UL_PAD_ENET1_TX_DATA0__ENET1_TDATA00 0x1b0b0
+                MX6UL_PAD_ENET1_TX_DATA1__ENET1_TDATA01 0x1b0b0
+                MX6UL_PAD_ENET1_TX_CLK__ENET1_REF_CLK1  0x40017051
+            >;
+        };
+
+        // Probe - 1 UART
+        pinctrl_uart3: uart3grp {
+            fsl,pins = <
+                MX6UL_PAD_UART3_RX_DATA__UART3_DCE_RX   0x1b0b1
+                MX6UL_PAD_UART3_TX_DATA__UART3_DCE_TX   0x1b0b1
+                MX6UL_PAD_UART3_RTS_B__UART3_DCE_RTS    0x1b0b1
+                MX6UL_PAD_UART3_CTS_B__UART3_DCE_CTS    0x1b0b1
+            >;
+        };
+
+        // Probe - 2 UART
+        pinctrl_uart1: uart1grp {
+            fsl,pins = <
+                MX6UL_PAD_UART1_RX_DATA__UART1_DCE_RX   0x1b0b1
+                MX6UL_PAD_UART1_TX_DATA__UART1_DCE_TX   0x1b0b1
+                MX6UL_PAD_UART1_RTS_B__UART1_DCE_RTS    0x1b0b1
+                MX6UL_PAD_UART1_CTS_B__UART1_DCE_CTS    0x1b0b1
+            >;
+        };
+
+        // Probe - 3 UART
+        pinctrl_uart8: uart8grp {
+            fsl,pins = <
+                MX6UL_PAD_LCD_DATA21__UART8_DCE_RX      0x1b0b1
+                MX6UL_PAD_LCD_DATA20__UART8_DCE_TX      0x1b0b1
+                MX6UL_PAD_ENET2_RX_ER__UART8_DCE_RTS    0x1b0b1
+                MX6UL_PAD_ENET2_TX_CLK__UART8_DCE_CTS   0x1b0b1
+            >;
+        };
+
+        // BLE Module
+        pinctrl_uart6: uart6grp {
+            fsl,pins = <
+                MX6UL_PAD_CSI_PIXCLK__UART6_DCE_RX      0x1b0b1
+                MX6UL_PAD_CSI_MCLK__UART6_DCE_TX        0x1b0b1
+            >;
+        };
+
+        // Console UART pins
+        pinctrl_uart5: uart5grp {
+            fsl,pins = <
+                MX6UL_PAD_UART5_TX_DATA__UART5_DCE_TX   0x1b0b1
+                MX6UL_PAD_UART5_RX_DATA__UART5_DCE_RX   0x1b0b1
+            >;
+        };
+
+        // micro SD card peripheral port pins
+        pinctrl_usdhc2: usdhc2grp {
+            fsl,pins = <
+                MX6UL_PAD_CSI_VSYNC__USDHC2_CLK         0x10039
+                MX6UL_PAD_CSI_HSYNC__USDHC2_CMD         0x17059
+                MX6UL_PAD_CSI_DATA00__USDHC2_DATA0      0x17059
+                MX6UL_PAD_CSI_DATA01__USDHC2_DATA1      0x17059
+                MX6UL_PAD_CSI_DATA02__USDHC2_DATA2      0x17059
+                MX6UL_PAD_CSI_DATA03__USDHC2_DATA3      0x17059
+            >;
+        };
+
+        // SPI 1 - MIP display
+        pinctrl_ecspi1_master: ecspi1grp1 {
+            fsl,pins = <
+                MX6UL_PAD_LCD_DATA22__ECSPI1_MOSI       0x10b0
+                MX6UL_PAD_LCD_DATA23__ECSPI1_MISO       0x10b0
+                MX6UL_PAD_CSI_DATA04__ECSPI1_SCLK       0x10b0
+                MX6UL_PAD_GPIO1_IO03__GPIO1_IO03        0x30b0
+            >;
+        };
+
+        // SPI 3 - Pressure sensor chip
+        pinctrl_ecspi3_master: ecspi3grp1 {
+            fsl,pins = <
+                MX6UL_PAD_UART2_CTS_B__ECSPI3_MOSI      0x10b0
+                MX6UL_PAD_UART2_RTS_B__ECSPI3_MISO      0x10b0
+                MX6UL_PAD_UART2_RX_DATA__ECSPI3_SCLK    0x10b0
+                MX6UL_PAD_GPIO1_IO02__GPIO1_IO02        0x10b0
+            >;
+        };
+
+        // USB 1 OTG port pins (Battery Charger)
+        pinctrl_usbotg1: usbotg1grp {
+            fsl,pins = <
+                MX6UL_PAD_GPIO1_IO00__ANATOP_OTG1_ID    0x17059
+                MX6UL_PAD_GPIO1_IO04__GPIO1_IO04        0x17059
+            >;
+        };
+
+        // AUDIO PWM - Beeper
+        pinctrl_pwm1_pwm: pwm1grp-pwm {
+            fsl,pins = <
+                MX6UL_PAD_GPIO1_IO08__PWM1_OUT          0x110b0
+            >;
+        };
+       pinctrl_pwm1_gpio: pwm1grp-gpio {
+            fsl,pins = <
+                MX6UL_PAD_GPIO1_IO08__GPIO1_IO08          0x130b0
+            >;
+        };
+
+        // Battery Charger Chip - I2C Bus definition.
+        pinctrl_i2c3: i2c3grp {
+            fsl,pins = <
+                MX6UL_PAD_ENET2_RX_DATA0__I2C3_SCL      0x4001b8b0
+                MX6UL_PAD_ENET2_RX_DATA1__I2C3_SDA      0x4001b8b0
+            >;
+        };
+        /* Battery Charger IRQ - Active Low Signal */
+        pinctrl_charger_irq: chargerIrq {
+            fsl,pins = <
+                MX6UL_PAD_CSI_DATA05__GPIO4_IO26        0x10b0
+            >;
+        };
+
+		// Battery Charger Chip - I2C Bus as GPIO definition.
+		pinctrl_i2c3_gpio: i2c3gpiogrp {
+			fsl,pins = <
+				MX6UL_PAD_ENET2_RX_DATA0__GPIO2_IO08	0x1b0b0
+				MX6UL_PAD_ENET2_RX_DATA1__GPIO2_IO09	0x1b0b0
+			>;
+		};
+
+        // General purpose pinctrl
+        pinctrl_hog: hoggrp {
+            fsl,pins = <
+                // Column (strobe) lines as outputs - Active low signals
+                MX6UL_PAD_JTAG_TRST_B__GPIO1_IO15       0x10b0  // KEYPAD_COL1
+                MX6UL_PAD_JTAG_MOD__GPIO1_IO10          0x10b0  // KEYPAD_COL2
+                MX6UL_PAD_JTAG_TMS__GPIO1_IO11          0x10b0  // KEYPAD_COL3
+
+                // Row lines as inputs, active high signals
+                MX6UL_PAD_JTAG_TDO__GPIO1_IO12          0x10b0  // KEYPAD_ROW1
+                MX6UL_PAD_JTAG_TDI__GPIO1_IO13          0x10b0  // KEYPAD_ROW2
+                MX6UL_PAD_JTAG_TCK__GPIO1_IO14          0x10b0  // KEYPAD_ROW3
+
+                // SD card control lines, Active low signals
+                MX6UL_PAD_SNVS_TAMPER7__GPIO5_IO07      0x10b0  // SDCARD_PWR&
+
+                // MIP Display, Active high signals
+                MX6UL_PAD_SNVS_TAMPER8__GPIO5_IO08      0x3031  // SER_LCD_EXTCOM
+                MX6UL_PAD_SNVS_TAMPER1__GPIO5_IO01      0x3031  // SER_LCD_ON_OFF
+                MX6UL_PAD_SNVS_TAMPER5__GPIO5_IO05      0x3031  // SER_LCD_BKLT_EN
+
+                // Probe 1 - Control lines
+                MX6UL_PAD_UART2_TX_DATA__GPIO1_IO20     0xb0b0  // PRB1_DET&
+                MX6UL_PAD_LCD_DATA17__GPIO3_IO22        0x10b0  // PRB1_OFF
+                MX6UL_PAD_GPIO1_IO01__GPIO1_IO01        0x10b0  // PRB1_EN&
+
+                // Probe 2 - Control lines
+                MX6UL_PAD_ENET2_TX_DATA0__GPIO2_IO11    0xb0b0  // PRB2_DET&
+                MX6UL_PAD_LCD_DATA18__GPIO3_IO23        0x10b0  // PRB2_OFF
+                MX6UL_PAD_ENET2_RX_EN__GPIO2_IO10       0x10b0  // PRB2_EN&
+
+                // Probe 3 - Control lines
+                MX6UL_PAD_SD1_CLK__GPIO2_IO17           0xb0b0  // PRB3_DET&
+                MX6UL_PAD_LCD_DATA19__GPIO3_IO24        0x10b0  // PRB3_OFF
+                MX6UL_PAD_SD1_CMD__GPIO2_IO16           0x10b0  // PRB3_EN&
+
+                // BLE Module
+                MX6UL_PAD_SD1_DATA0__GPIO2_IO18         0x10b0  // BLEMOD_PWR*
+                MX6UL_PAD_SD1_DATA2__GPIO2_IO20         0x10b0  // BLE_MOD_READ_ID*
+                MX6UL_PAD_SD1_DATA3__GPIO2_IO21         0x10b0  // BLEMOD_WAKEUP*
+
+                // LCD Module
+                MX6UL_PAD_LCD_RESET__GPIO3_IO04         0x10b0  // LCD_RESET&
+                MX6UL_PAD_SNVS_TAMPER9__GPIO5_IO09      0x10b0  // LCD2_STANDBY&
+                MX6UL_PAD_SNVS_TAMPER0__GPIO5_IO00      0x10b0  // LCD2_PWR_EN&
+
+                // Ethernet control lines
+                MX6UL_PAD_CSI_DATA06__GPIO4_IO27        0x10b0  // ENET1_INT&
+                MX6UL_PAD_CSI_DATA07__GPIO4_IO28        0x10b0  // ENET1_PWR&
+
+                // PWR_ON_OFF_C - Input line
+                MX6UL_PAD_SNVS_TAMPER2__GPIO5_IO02      0x10b0  // PWR_ON_OFF_C
+
+                MX6UL_PAD_SD1_DATA1__GPIO2_IO19         0x10b0  // CHRGR_PRESENT
+
+                MX6UL_PAD_GPIO1_IO05__GPIO1_IO05        0x10b0  // SPARE_W1_TP65
+                MX6UL_PAD_LCD_DATA16__GPIO3_IO21        0x10b0  // SPARE_W10_TP1
+                MX6UL_PAD_NAND_DQS__GPIO4_IO16          0x10b0  // SPARE_M2_TP27 
+
+            >;
+        };
+    };
+};
-- 
2.17.1

