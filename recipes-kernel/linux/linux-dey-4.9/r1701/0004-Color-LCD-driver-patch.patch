From a1a2438ec7a67ae0c87acb463ab6cdf4e6ac6647 Mon Sep 17 00:00:00 2001
From: Devang Patel <dpatel@hach.com>
Date: Fri, 16 Feb 2018 09:21:45 -0700
Subject: [PATCH] Color LCD driver patch

---
 drivers/video/fbdev/mxsfb.c | 75 +++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 75 insertions(+)

diff --git a/drivers/video/fbdev/mxsfb.c b/drivers/video/fbdev/mxsfb.c
index 52ee3e5163bc..742211278fed 100644
--- a/drivers/video/fbdev/mxsfb.c
+++ b/drivers/video/fbdev/mxsfb.c
@@ -64,6 +64,8 @@
 #include <linux/uaccess.h>
 
 #include "mxc/mxc_dispdrv.h"
+#include <linux/gpio.h>
+#include <linux/delay.h>
 
 #define REG_SET	4
 #define REG_CLR	8
@@ -268,6 +270,14 @@ struct mxsfb_info {
 #ifdef CONFIG_FB_MXC_OVERLAY
 	struct mxsfb_layer overlay;
 #endif
+
+    /* r1701 - start */
+    int lcd_pwr_en;
+    int lcd_standby;
+    int lcd_reset;
+    int lcd_lvl_sftr_en;
+    int lcd_lvl_sftr_V2P5_pwr_en;
+    /* r1701 - end */
 };
 
 #define mxsfb_is_v3(host) (host->devdata->ipversion == 3)
@@ -2195,6 +2205,71 @@ static int mxsfb_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	}
 
+	/* r1701 start */
+    /* LCD Initialization routine */
+    host->lcd_pwr_en                = of_get_named_gpio(pdev->dev.of_node, "gpios", 0);    /* LCD_PWR_EN&  */
+    host->lcd_reset                 = of_get_named_gpio(pdev->dev.of_node, "gpios", 1);    /* LCD_RESET&   */
+    host->lcd_standby               = of_get_named_gpio(pdev->dev.of_node, "gpios", 2);    /* LCD_STANDBY& */
+    host->lcd_lvl_sftr_en           = of_get_named_gpio(pdev->dev.of_node, "gpios", 3);    /* LCD_XLTR_EN& */
+    host->lcd_lvl_sftr_V2P5_pwr_en  = of_get_named_gpio(pdev->dev.of_node, "gpios", 4);    /* V2P5_PWR_EN  */
+
+    // Request all GPIOs.
+    ret = devm_gpio_request_one(&pdev->dev, host->lcd_lvl_sftr_V2P5_pwr_en, GPIOF_OUT_INIT_HIGH, "V2P5_PWR_EN");
+    if(ret < 0){
+        dev_err(&pdev->dev, "Failed to request V2P5_PWR_EN gpio pin\n");
+        return -ENODEV;
+    }
+    else{
+        gpio_export(host->lcd_lvl_sftr_V2P5_pwr_en, 0);
+        gpio_set_value(host->lcd_lvl_sftr_V2P5_pwr_en, 1);
+        mdelay(10);
+    }
+
+    ret = devm_gpio_request_one(&pdev->dev, host->lcd_lvl_sftr_en, GPIOF_OUT_INIT_LOW, "LCD_XLTR_EN");
+    if(ret < 0){
+        dev_err(&pdev->dev, "Failed to request LCD_XLTR_EN gpio pin\n");
+        return -ENODEV;
+    }
+    else{
+        gpio_export(host->lcd_lvl_sftr_en, 0);
+        gpio_set_value(host->lcd_lvl_sftr_en, 0);
+        mdelay(50);
+    }
+
+    ret = devm_gpio_request_one(&pdev->dev, host->lcd_pwr_en, GPIOF_OUT_INIT_LOW, "LCD_PWR_EN");
+    if(ret < 0){
+        dev_err(&pdev->dev, "Failed to request LCD_PWR_EN gpio pin\n");
+        return -ENODEV;
+    }
+    else{
+        gpio_export(host->lcd_pwr_en, 0);
+        mdelay(50);
+    }
+
+    ret = devm_gpio_request_one(&pdev->dev, host->lcd_standby, GPIOF_OUT_INIT_HIGH, "LCD_STANDBY");
+    if(ret < 0){
+        dev_err(&pdev->dev, "Failed to request LCD_STANDBY gpio pin\n");
+        return -ENODEV;
+    }
+    else{
+        gpio_export(host->lcd_standby, 0);
+        gpio_set_value(host->lcd_standby, 1);
+    }
+
+    ret = devm_gpio_request_one(&pdev->dev, host->lcd_reset, GPIOF_OUT_INIT_HIGH, "LCD_RESET");
+    if(ret < 0){
+        dev_err(&pdev->dev, "Failed to request LCD_RESET gpio pin\n");
+        return -ENODEV;
+    }
+    else{
+        gpio_export(host->lcd_reset, 0);
+        gpio_set_value(host->lcd_reset, 1);
+        mdelay(50);
+        gpio_set_value(host->lcd_reset, 0);
+    }
+
+    /* r1701 end */
+
 	fb_info = framebuffer_alloc(0, &pdev->dev);
 	if (!fb_info) {
 		dev_err(&pdev->dev, "Failed to allocate fbdev\n");
-- 
2.11.0

