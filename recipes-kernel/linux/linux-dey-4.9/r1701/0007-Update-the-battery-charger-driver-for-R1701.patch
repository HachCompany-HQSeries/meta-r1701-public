From 9805ff06b91e2767de58086c0a2d290bc5aa342c Mon Sep 17 00:00:00 2001
From: ryang <ryang@hach.com>
Date: Fri, 6 Jul 2018 09:47:58 -0600
Subject: [PATCH 7/9] Update the battery charger driver for R1701

---
 drivers/power/supply/bq25890_charger.c | 78 +++++++++++++++++++++++++++-------
 1 file changed, 63 insertions(+), 15 deletions(-)

diff --git a/drivers/power/supply/bq25890_charger.c b/drivers/power/supply/bq25890_charger.c
index f993a55cde20..12cec4abe311 100644
--- a/drivers/power/supply/bq25890_charger.c
+++ b/drivers/power/supply/bq25890_charger.c
@@ -24,7 +24,7 @@
 #include <linux/interrupt.h>
 #include <linux/delay.h>
 #include <linux/usb/phy.h>
-
+#include <linux/usb.h>
 #include <linux/acpi.h>
 #include <linux/of.h>
 
@@ -84,6 +84,7 @@ struct bq25890_state {
 	u8 vsys_status;
 	u8 boost_fault;
 	u8 bat_fault;
+	u8 chrg_type;
 };
 
 struct bq25890_device {
@@ -368,7 +369,16 @@ enum bq25890_chrg_fault {
 	CHRG_FAULT_THERMAL_SHUTDOWN,
 	CHRG_FAULT_TIMER_EXPIRED,
 };
-
+enum bq25890_chrg_type {
+	CHRG_NO_INPUT,
+	CHRG_USB_HOST_SDP,
+	CHRG_USB_CDP,
+	CHRG_USB_DCP,
+	CHRG_HIGH_VOL_DCP,
+	CHRG_UNKNOWN_ADAPTER,
+	CHRG_NON_STANDARD_ADAPTER,
+	CHRG_OTG,
+};
 static int bq25890_power_supply_get_property(struct power_supply *psy,
 					     enum power_supply_property psp,
 					     union power_supply_propval *val)
@@ -452,7 +462,17 @@ static int bq25890_power_supply_get_property(struct power_supply *psy,
 	case POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:
 		val->intval = bq25890_find_val(bq->init_data.iterm, TBL_ITERM);
 		break;
-
+	case POWER_SUPPLY_PROP_SCOPE:
+		if (state.chrg_type == CHRG_USB_HOST_SDP) {
+			val->intval = POWER_SUPPLY_SCOPE_SYSTEM;
+		}
+		else if (state.chrg_type == CHRG_OTG) {
+			val->intval = POWER_SUPPLY_SCOPE_UNKNOWN;
+		}
+		else {
+			val->intval = POWER_SUPPLY_SCOPE_DEVICE;
+		}
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -474,7 +494,8 @@ static int bq25890_get_chip_state(struct bq25890_device *bq,
 		{F_VSYS_STAT,	&state->vsys_status},
 		{F_BOOST_FAULT, &state->boost_fault},
 		{F_BAT_FAULT,	&state->bat_fault},
-		{F_CHG_FAULT,	&state->chrg_fault}
+		{F_CHG_FAULT,	&state->chrg_fault},
+		{F_VBUS_STAT,   &state->chrg_type},
 	};
 
 	for (i = 0; i < ARRAY_SIZE(state_fields); i++) {
@@ -484,7 +505,9 @@ static int bq25890_get_chip_state(struct bq25890_device *bq,
 
 		*state_fields[i].data = ret;
 	}
-
+	if (state->chrg_type == CHRG_OTG) {
+		state->online = 1;
+	}
 	dev_dbg(bq->dev, "S:CHG/PG/VSYS=%d/%d/%d, F:CHG/BOOST/BAT=%d/%d/%d\n",
 		state->chrg_status, state->online, state->vsys_status,
 		state->chrg_fault, state->boost_fault, state->bat_fault);
@@ -615,6 +638,10 @@ static int bq25890_hw_init(struct bq25890_device *bq)
 	ret = bq25890_field_write(bq, F_WD, 0);
 	if (ret < 0)
 		return ret;
+	/* disable boost mode thermal protection */
+	ret = bq25890_field_write(bq, F_BHOT, 0x03);
+	if (ret < 0)
+		return ret;
 
 	/* initialize currents/voltages and other parameters */
 	for (i = 0; i < ARRAY_SIZE(init_data); i++) {
@@ -650,6 +677,7 @@ static enum power_supply_property bq25890_power_supply_props[] = {
 	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,
 	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,
 	POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT,
+	POWER_SUPPLY_PROP_SCOPE,
 };
 
 static char *bq25890_charger_supplied_to[] = {
@@ -684,19 +712,32 @@ static void bq25890_usb_work(struct work_struct *data)
 			container_of(data, struct bq25890_device, usb_work);
 
 	switch (bq->usb_event) {
-	case USB_EVENT_ID:
+	case USB_BUS_ADD://USB_EVENT_ID:
 		/* Enable boost mode */
 		ret = bq25890_field_write(bq, F_OTG_CFG, 1);
+
 		if (ret < 0)
 			goto error;
+
+		mutex_lock(&bq->lock);
+		bq->state.online = 1;
+		bq->state.chrg_type = CHRG_OTG;
+		mutex_unlock(&bq->lock);
+
 		break;
 
-	case USB_EVENT_NONE:
+	case USB_BUS_REMOVE://USB_EVENT_NONE:
 		/* Disable boost mode */
 		ret = bq25890_field_write(bq, F_OTG_CFG, 0);
+
 		if (ret < 0)
 			goto error;
 
+		mutex_lock(&bq->lock);
+		bq->state.online = 0;
+		bq->state.chrg_type = CHRG_NO_INPUT;
+		mutex_unlock(&bq->lock);
+
 		power_supply_changed(bq->charger);
 		break;
 	}
@@ -713,9 +754,10 @@ static int bq25890_usb_notifier(struct notifier_block *nb, unsigned long val,
 	struct bq25890_device *bq =
 			container_of(nb, struct bq25890_device, usb_nb);
 
-	bq->usb_event = val;
-	queue_work(system_power_efficient_wq, &bq->usb_work);
-
+	if (val == USB_BUS_ADD || val == USB_BUS_REMOVE) {
+		bq->usb_event = val;
+		queue_work(system_power_efficient_wq, &bq->usb_work);
+	}
 	return NOTIFY_OK;
 }
 
@@ -870,11 +912,16 @@ static int bq25890_probe(struct i2c_client *client,
 	}
 
 	/* OTG reporting */
-	bq->usb_phy = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);
+
+	bq->usb_phy = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2); //devm_usb_get_phy_by_phandle(dev, "fsl,usbphy", 0);
 	if (!IS_ERR_OR_NULL(bq->usb_phy)) {
 		INIT_WORK(&bq->usb_work, bq25890_usb_work);
 		bq->usb_nb.notifier_call = bq25890_usb_notifier;
-		usb_register_notifier(bq->usb_phy, &bq->usb_nb);
+		//usb_register_notifier(bq->usb_phy, &bq->usb_nb);
+		usb_register_notify(&bq->usb_nb);
+	}
+	else {
+		dev_err(dev, "Failed to register usb event\n");
 	}
 
 	ret = devm_request_threaded_irq(dev, client->irq, NULL,
@@ -894,7 +941,8 @@ static int bq25890_probe(struct i2c_client *client,
 
 irq_fail:
 	if (!IS_ERR_OR_NULL(bq->usb_phy))
-		usb_unregister_notifier(bq->usb_phy, &bq->usb_nb);
+		//usb_unregister_notifier(bq->usb_phy, &bq->usb_nb);
+		usb_unregister_notify(&bq->usb_nb);
 
 	return ret;
 }
@@ -906,8 +954,8 @@ static int bq25890_remove(struct i2c_client *client)
 	power_supply_unregister(bq->charger);
 
 	if (!IS_ERR_OR_NULL(bq->usb_phy))
-		usb_unregister_notifier(bq->usb_phy, &bq->usb_nb);
-
+		//usb_unregister_notifier(bq->usb_phy, &bq->usb_nb);
+	    usb_unregister_notify(&bq->usb_nb);
 	/* reset all registers to default values */
 	bq25890_chip_reset(bq);
 
-- 
2.11.0

