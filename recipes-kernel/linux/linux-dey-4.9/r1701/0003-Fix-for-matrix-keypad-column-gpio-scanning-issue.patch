From 65c2c95028d4de3e53a06342aa696d3ef85a4874 Mon Sep 17 00:00:00 2001
From: ryang <ryang@hach.com>
Date: Tue, 18 Sep 2018 09:10:24 -0600
Subject: [PATCH 3/9] Fix-for-matrix-keypad-column-gpio-scanning-issue

---
 drivers/input/keyboard/matrix_keypad.c | 67 ++++++++++++++++++++++++++++++----
 1 file changed, 60 insertions(+), 7 deletions(-)

diff --git a/drivers/input/keyboard/matrix_keypad.c b/drivers/input/keyboard/matrix_keypad.c
index 7f12b6579f82..3a8dc4232594 100644
--- a/drivers/input/keyboard/matrix_keypad.c
+++ b/drivers/input/keyboard/matrix_keypad.c
@@ -39,6 +39,7 @@ struct matrix_keypad {
 	bool scan_pending;
 	bool stopped;
 	bool gpio_all_disabled;
+    unsigned int key_wakeup_gpio;
 };
 
 /*
@@ -52,10 +53,14 @@ static void __activate_col(const struct matrix_keypad_platform_data *pdata,
 	bool level_on = !pdata->active_low;
 
 	if (on) {
-		gpio_direction_output(pdata->col_gpios[col], level_on);
+		/* Scan sleep API is not changing GPIO lines as expected.       */
+		/* hence we are using standard GPIO set API.                    */
+		/* gpio_direction_output(pdata->col_gpios[col], level_on);      */
+		gpio_set_value(pdata->col_gpios[col], level_on);
 	} else {
-		gpio_set_value_cansleep(pdata->col_gpios[col], !level_on);
-		gpio_direction_input(pdata->col_gpios[col]);
+		/* gpio_set_value_cansleep(pdata->col_gpios[col], !level_on); */
+		/* gpio_direction_input(pdata->col_gpios[col]); */
+		gpio_set_value(pdata->col_gpios[col], !level_on);
 	}
 }
 
@@ -80,7 +85,11 @@ static void activate_all_cols(const struct matrix_keypad_platform_data *pdata,
 static bool row_asserted(const struct matrix_keypad_platform_data *pdata,
 			 int row)
 {
-	return gpio_get_value_cansleep(pdata->row_gpios[row]) ?
+	/* Scan sleep API is not changing GPIO lines as expected.       */
+	/* hence we are using standard GPIO set API.                    */
+	/* return gpio_get_value_cansleep(pdata->row_gpios[row]) ?	*/
+	/*		!pdata->active_low : pdata->active_low;		*/
+	return gpio_get_value(pdata->row_gpios[row]) ?
 			!pdata->active_low : pdata->active_low;
 }
 
@@ -195,7 +204,12 @@ static irqreturn_t matrix_keypad_interrupt(int irq, void *id)
 	spin_unlock_irqrestore(&keypad->lock, flags);
 	return IRQ_HANDLED;
 }
-
+static irqreturn_t matrix_keypad_wakeup_interrupt(int irq, void *id)
+{
+	//struct matrix_keypad *keypad = id;
+	//disable_irq_nosync(gpio_to_irq(keypad->key_wakeup_gpio));
+	return IRQ_HANDLED;
+}
 static int matrix_keypad_start(struct input_dev *dev)
 {
 	struct matrix_keypad *keypad = input_get_drvdata(dev);
@@ -224,6 +238,9 @@ static void matrix_keypad_stop(struct input_dev *dev)
 	 * we should disable them now.
 	 */
 	disable_row_irqs(keypad);
+
+	/* clear the last key state */
+	memset(keypad->last_key_state, 0, sizeof(keypad->last_key_state));
 }
 
 #ifdef CONFIG_PM_SLEEP
@@ -275,11 +292,13 @@ static int matrix_keypad_suspend(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct matrix_keypad *keypad = platform_get_drvdata(pdev);
 
-	matrix_keypad_stop(keypad->input_dev);
+	//matrix_keypad_stop(keypad->input_dev);
 
 	if (device_may_wakeup(&pdev->dev))
 		matrix_keypad_enable_wakeup(keypad);
 
+	enable_irq(gpio_to_irq(keypad->key_wakeup_gpio));
+
 	return 0;
 }
 
@@ -288,10 +307,12 @@ static int matrix_keypad_resume(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct matrix_keypad *keypad = platform_get_drvdata(pdev);
 
+	disable_irq_nosync(gpio_to_irq(keypad->key_wakeup_gpio));
+
 	if (device_may_wakeup(&pdev->dev))
 		matrix_keypad_disable_wakeup(keypad);
 
-	matrix_keypad_start(keypad->input_dev);
+	//matrix_keypad_start(keypad->input_dev);
 
 	return 0;
 }
@@ -358,6 +379,31 @@ static int matrix_keypad_init_gpio(struct platform_device *pdev,
 		}
 	}
 
+	err = gpio_request(keypad->key_wakeup_gpio, "matrix_kbd_wakeup");
+	if (err) {
+			dev_err(&pdev->dev,
+				"failed to request wakeup GPIO%d\n",
+				keypad->key_wakeup_gpio);
+			return err;
+	}
+
+	gpio_direction_input(keypad->key_wakeup_gpio);
+	gpio_set_debounce(keypad->key_wakeup_gpio, pdata->debounce_ms);      // Debounce the button
+	gpio_export(keypad->key_wakeup_gpio, false);         // The GPIO will appear in /sys/class/gpio
+
+	err = request_any_context_irq(
+					gpio_to_irq(keypad->key_wakeup_gpio),
+					matrix_keypad_wakeup_interrupt,
+					IRQF_TRIGGER_RISING,
+					"matrix-keypad-wakeup", keypad);
+	if (err < 0) {
+				dev_err(&pdev->dev,
+					"Unable to acquire interrupt for wakeup GPIO line %i\n",
+					keypad->key_wakeup_gpio);
+			return err;
+	}
+	disable_irq_nosync(gpio_to_irq(keypad->key_wakeup_gpio));
+
 	/* initialized as disabled - enabled by input->open */
 	disable_row_irqs(keypad);
 	return 0;
@@ -394,6 +440,10 @@ static void matrix_keypad_free_gpio(struct matrix_keypad *keypad)
 
 	for (i = 0; i < pdata->num_col_gpios; i++)
 		gpio_free(pdata->col_gpios[i]);
+
+	free_irq(gpio_to_irq(keypad->key_wakeup_gpio), keypad);
+    gpio_unexport(keypad->key_wakeup_gpio);
+	gpio_free(keypad->key_wakeup_gpio);
 }
 
 #ifdef CONFIG_OF
@@ -472,6 +522,7 @@ static int matrix_keypad_probe(struct platform_device *pdev)
 	const struct matrix_keypad_platform_data *pdata;
 	struct matrix_keypad *keypad;
 	struct input_dev *input_dev;
+	struct device_node *np = pdev->dev.of_node;
 	int err;
 
 	pdata = dev_get_platdata(&pdev->dev);
@@ -493,6 +544,8 @@ static int matrix_keypad_probe(struct platform_device *pdev)
 		goto err_free_mem;
 	}
 
+	keypad->key_wakeup_gpio = of_get_named_gpio(np, "key-wakeup-gpios", 0);
+
 	keypad->input_dev = input_dev;
 	keypad->pdata = pdata;
 	keypad->row_shift = get_count_order(pdata->num_col_gpios);
-- 
2.11.0

